<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zjjfly.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false,"width":250},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="聚合如果你想用一种方式计算流的元素的合或者把它们组合成一个结果,你可以使用reduce方法.它接收一个二元函数并不断应用它,第一次的参数是是流的前两个元素,然后是第一次调用的结果和流的第三个元素,依次类推,直到流的最后. 12Stream&lt;Integer&gt; values &#x3D; Stream.of(1, 2, 3, 4, 5);Optional&lt;Integer&gt; sum &#x3D; v">
<meta property="og:type" content="article">
<meta property="og:title" content="快学Java8 第二章下">
<meta property="og:url" content="https://zjjfly.github.io/2017/09/03/2017-9-3-%E5%BF%AB%E5%AD%A6Java8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%8B/index.html">
<meta property="og:site_name" content="zjjfly&#39;s blog">
<meta property="og:description" content="聚合如果你想用一种方式计算流的元素的合或者把它们组合成一个结果,你可以使用reduce方法.它接收一个二元函数并不断应用它,第一次的参数是是流的前两个元素,然后是第一次调用的结果和流的第三个元素,依次类推,直到流的最后. 12Stream&lt;Integer&gt; values &#x3D; Stream.of(1, 2, 3, 4, 5);Optional&lt;Integer&gt; sum &#x3D; v">
<meta property="og:locale">
<meta property="og:image" content="https://zjjfly.github.io/images/20170903/java8-2-1.png">
<meta property="article:published_time" content="2017-09-03T01:32:28.000Z">
<meta property="article:modified_time" content="2023-08-21T11:37:50.372Z">
<meta property="article:author" content="JunJie Zi">
<meta property="article:tag" content="Java Java8">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zjjfly.github.io/images/20170903/java8-2-1.png">

<link rel="canonical" href="https://zjjfly.github.io/2017/09/03/2017-9-3-%E5%BF%AB%E5%AD%A6Java8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh'
  };
</script>

  <title>快学Java8 第二章下 | zjjfly's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="zjjfly's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zjjfly's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Java,Clojure,Scala...</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://zjjfly.github.io/2017/09/03/2017-9-3-%E5%BF%AB%E5%AD%A6Java8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JunJie Zi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjjfly's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          快学Java8 第二章下
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-09-03 09:32:28" itemprop="dateCreated datePublished" datetime="2017-09-03T09:32:28+08:00">2017-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-21 19:37:50" itemprop="dateModified" datetime="2023-08-21T19:37:50+08:00">2023-08-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>如果你想用一种方式计算流的元素的合或者把它们组合成一个结果,你可以使用<code>reduce</code>方法.它接收一个二元函数并不断应用它,第一次的参数是是流的前两个元素,然后是第一次调用的结果和流的第三个元素,依次类推,直到流的最后.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; values = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; sum = values.reduce((x, y) -&gt; x + y)</span><br></pre></td></tr></table></figure>

<p>这种情况下,<code>reduce</code>计算的是Stream中的数字的和.这个方法返回的是一个<code>Optional</code>,因为Stream可能是空的.你其实可以使用<code>values.reduce(Integer::sum)</code>代替<code>values.reduce((x, y) -&gt; x + y)</code>.</p>
<span id="more"></span>

<p>一般来说,如果聚合方法有一个聚合操作<code>op</code>,那么该聚合会产生<code>v0 op v1 op v2 op ...</code>,其中的<code>vi op vi+1</code>表示函数调用<code>op(vi,vi+1)</code>.这个操作应该是满足结合律的,也即是说这个操作和你组合元素的顺序无关,<code>(x op y) op z = x op (y op z)</code>.这样就允许使用并行流进行有效的聚合.<br>在实践中,有很多有用的结合操作,例如和,积,字符串连接,最大值和最小值,并集和交集.减法是一个不满足结合律的操作的例子.例如,<code>(6-3)-2≠6-(3-2)</code>.<br>通常,会有一个标识<code>e</code>使得<code>e op x=x</code>,你可以使用这个元素作为计算的起始.例如,在加法中,0就是这个标识<code>e</code>.然后调用<code>reduce</code>的第二种形式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> values.reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>

<p>如果流是空的,这个标识值就会被返回.这样你就不需要处理<code>Optional</code>类了.现在假设你有一个包含多个对象的流,你想要对对象们的某个属性求和,比如流中字符串的总长.你不能使用简单形式的<code>reduce</code>方法,因为它需要的一个函数<code>(T,T)-&gt;T</code>,其中参数类型和返回值类型都必须是一样的,而现在的情况下,这两种类型是不同的,流的元素的类型是字符串,而累积结果的类型是整型.幸好有另一种形式的<code>reduce</code>可以处理这个情况.<br>首先,你要提供一个累加器函数<code>(total,word)-&gt;total+word.length()</code>.这个函数会被重复的调用,形成累加值.但是当并行计算时,会有多个累加值,你需要把它们再累加起来.为了这一点,你需要提供第二个函数.完整代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> words.reduce(<span class="number">0</span>, (s, word) -&gt; s + word.length(), (total, subtotal) -&gt; total + subtotal);</span><br></pre></td></tr></table></figure>

<p>实践中,你可能不会大量使用<code>ruduce</code>方法,通常,<strong>更简单的方法是映射到一个数字流并使用它的方法来计算总和,最大值和最小值</strong>.在这个例子中,可以调用<code>words.mapToInt(String::length).sum()</code>,它更简单也更高效,因为它不涉及装箱拆箱.</p>
<h2 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h2><p>当你对一个流进行了处理,你通常想要看到结果而不是吧它们聚合成一个值.你可以调用<code>iterator</code>方法,生成一个旧式的迭代器用来访问元素.或者调用<code>toArray</code>获取流元素组成的一个数组.<br>因为在运行时产生一个泛型的数组是不可能的,<strong>表达式<code>stream.toArray()</code>返回的是一个<code>Object[]</code>数组.如果你想得到一个正确的类型的数组,传入数组的构造器引用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(<span class="string">&quot;what&quot;</span>, <span class="string">&quot;which&quot;</span>, <span class="string">&quot;where&quot;</span>);</span><br><span class="line">String[] result = words.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>现在假设你想要把结果收集到一个<code>HashSet</code>中,如果集合并行化了,你无法直接把元素放入到单个<code>HashSet</code>中,因为<code>HashSet</code>不是线程安全的.由于这个原因,你也不能使用<code>reduce</code>,每个块都需要一个空的<code>HashSet</code>,但<code>reduce</code>方法只让你提供一个标识值.可以使用<code>collect</code>,它有三个参数:</p>
<ol>
<li>一个生成目标对象实例的生产者,比如,一个<code>HashSet</code>的构造器.</li>
<li>一个把元素添加到目标对象的累加器.例如,<code>add</code>方法.</li>
<li>一个把两个对象合成一个的组合器,如<code>addAll</code>方法.</li>
</ol>
<p>注意,目标对象不一定是集合,也可以是<code>StringBuilder</code>或一个跟踪数量和总和的对象.<br>下面是产生一个<code>HashSet</code>的<code>collect</code>的写法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; integers = nums.collect(HashSet::<span class="keyword">new</span>, HashSet&lt;Integer&gt;::add, HashSet::addAll);</span><br></pre></td></tr></table></figure>

<p>实践中,你不需要这样写,因为有一个便利的<code>Collector</code>接口代替这三个函数,并且有包含了很多常用的收集器的类<code>Collectors</code>.把一个流收集到一个list或set,你只需简单的调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result = nums.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result = nums.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>

<p>如果你想要控制获得的set类型,可以像下面这样调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; result = nums.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p>如果想要通过拼接把流中的所有字符串收集起来,你可以调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> StreamFactory.stringStream().collect(Collectors.joining());</span><br></pre></td></tr></table></figure>

<p>如果你想要在字符串之间加入分隔符,可以把它传入<code>joining</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">delimiter</span> <span class="operator">=</span> StreamFactory.stringStream().collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>如果流中包含的对象不是String类型的,你需要先把它们转换成字符串,像这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">persons</span> <span class="operator">=</span> StreamFactory.objectStream().map(StreamFactory.Person::toString)</span><br><span class="line">                              .collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>如果你想要对流进行聚合求和,平均值,最大值v,最小值,可以使用<code>Collectors</code>中的<code>summarizing</code>方法.这些方法接收一个可以把流中的对象映射到数字的函数,返回一个类型是<code>(Int|Long|Double)SummaryStatistics</code>的对象,它带有获取和,平均值,最大值,最小值的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span>words.collect(Collectors.summarizingInt(String::length));</span><br><span class="line"><span class="type">double</span> <span class="variable">averageLength</span> <span class="operator">=</span> statistics.getAverage();</span><br><span class="line"><span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> statistics.getMax();</span><br></pre></td></tr></table></figure>

<p>到此为止,我们已经看到如果聚合和收集流中的值.但你可能只是想要打印它们或把它们放入数据库,你可以使用<code>forEach</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>你传入的这个函数会被应用到流中的每个元素上.在一个并行流中,你需要保证这个函数式可以被并发地执行的.<br>**在一个并行流上,元素可能会被以任意的顺序遍历,如果你想按照流中的属性执行,调用<code>forEachOrdered</code>.**当然,这样你就放弃了并行带来的好处.<br><code>forEach</code>和<code>forEachOrdered</code>方法都是终结操作,调用它们之后,你无法再使用流了.如果你想继续使用流,使用之前提到的<code>peek</code>.</p>
<h2 id="将结果收集到Map"><a href="#将结果收集到Map" class="headerlink" title="将结果收集到Map"></a>将结果收集到Map</h2><p>假设你有一个<code>Person</code>的流,你想把元素收集到一个Map以便可以使用它们的ID来进行查找.你可以使用<code>Colletors.toMap</code>方法,它有两个函数参数,分别用来生成map的键和值.例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; idToName = people.collect(Collectors.toMap(Person::getId, Person::getName));</span><br></pre></td></tr></table></figure>

<p>一般情况下,值应该是实际的元素,所以使用<code>Function.identity()</code>作为第二个参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; idToPerson = people.collect(Collectors.toMap(Person::getId, Function.identity()));</span><br></pre></td></tr></table></figure>

<p>如果多个元素有相同的键,那么收集器会抛出<code>IllegalStateException</code>异常.但你可以通过提供第三个函数参数重写这个行为.这个函数的参数是已有值和新的值,你可以返回它们中的一个或者根据它们另外产生一个值来返回.这里,我们构造一个map,对于系统的支持的所有语言,以其默认语言环境中的名字作为键,以其本地化的名字作为值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Locale&gt; locales = Stream.of(Locale.getAvailableLocales());</span><br><span class="line">Map&lt;String, String&gt; languageNames = locales.collect(Collectors.toMap(</span><br><span class="line">        Locale::getDisplayLanguage,</span><br><span class="line">        l -&gt; l.getDisplayLanguage(l),</span><br><span class="line">        (existingValue, newValue) -&gt; existingValue));</span><br></pre></td></tr></table></figure>

<p>但是,如果我们希望知道指定国家的所有语言,那么我们需要一个<code>Map&lt;String,Set&lt;String&gt;&gt;</code>对象.首先,我们把每种语言存到单个集中,当发现指定国家的新的语言时,我们就将已有值和新值组合成一个新的集合.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;String&gt;&gt; countryLanguageSets = locales</span><br><span class="line">        .collect(Collectors.toMap(Locale::getDisplayCountry, l -&gt; Collections.singleton(l.getDisplayLanguage()),</span><br><span class="line">                                  (a, b) -&gt; &#123;</span><br><span class="line">                                      HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(a);</span><br><span class="line">                                      set.addAll(b);</span><br><span class="line">                                      <span class="keyword">return</span> set;</span><br><span class="line">                                  &#125;));</span><br></pre></td></tr></table></figure>

<p>如果你想要的是一个<code>TreeMap</code>,那么你需要提供一个构造器引用作为第四个参数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer, Person&gt; id2Person = people</span><br><span class="line">        .collect(Collectors.toMap(Person::getId, Function.identity(), (o, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        &#125;, TreeMap::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p>对于上面的三种<code>toMap</code>方法,都有对应的<code>toConcurrentMap</code>方法,用来产生一个并发map.在并行收集过程中应该只使用一个并发的map.当在并行流中使用并发map时,一个共享的map要比合并map更高效,当然,使用共享map无法保证顺序.</p>
<h2 id="分组和分片"><a href="#分组和分片" class="headerlink" title="分组和分片"></a>分组和分片</h2><p>在之前的章节中,我们看到怎么收集特定国家的所有语言.但是,那个代码很冗长.对有共同特性的值进行分组是是很常见的需求,<code>groupingBy</code>方法就是专门用于分组的.<br>还是对国家语言分组的问题,首先,我们构建这样一个map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Locale&gt;&gt; country2Locales= locales.collect(Collectors.groupingBy(Locale::getCountry));</span><br></pre></td></tr></table></figure>

<p>函数<code>Local::getCountry</code>是进行分组的分类函数.现在可以查找指定国家中所有语言,例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Locale&gt; swissLocales = country2Locales.get(<span class="string">&quot;CH&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当分类函数是一个predicate函数时,流元素会被分为两组:一组是函数会返回true的元素,另一组是返回false的元素.在这种情况下,使用<code>partitionBy</code>方法.例如,把所有语言环境分为两组,一组是使用英语一组使用的是其他语言:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Locale&gt;&gt; englishAndOtherLocales = locales.collect(Collectors.partitioningBy(l -&gt; l.getLanguage().equals(<span class="string">&quot;en&quot;</span>)));</span><br><span class="line">List&lt;Locale&gt; englishLocales = englishAndOtherLocales.get(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p><code>groupingBy</code>方法生成的map的值是list,如果你想要使用某种方式处理这些list的时候,你要提供一个downstream的收集器.例如,你想要set而不是list,你可以使用<code>Collectors.toSet</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;Locale&gt;&gt; countryToLocaleSet = locales.collect(groupingBy(Locale::getCountry, toSet()));</span><br></pre></td></tr></table></figure>

<p>还有若干其他的收集器可以用于分好组的元素的downstream的处理.<br><code>counting</code>产生被收集的元素的个数,例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; countryToLocaleCounts = locales.collect(groupingBy(Locale::getCountry, counting()));</span><br></pre></td></tr></table></figure>

<p><code>summing(Int|Long|Double)</code>接受一个函数参数,应用这个函数到downstream的元素,生成它们的合,例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; stateToPopulation = cities.collect(groupingBy(City::getState, summingInt(City::getPopulation)));</span><br></pre></td></tr></table></figure>

<p><code>maxBy</code>和<code>minBy</code>接收一个比较器并产生downstream元素的最大值和最小值.例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Optional&lt;City&gt;&gt; stateToLargestCity = cities</span><br><span class="line">        .collect(groupingBy(City::getState, maxBy(Comparator.comparingInt(City::getPopulation))));</span><br></pre></td></tr></table></figure>

<p><code>mapping</code>应用一个函数到downstream,它还需要另一个收集器处理之前的结果.还记得上一个章节中的收集国家的所有语言到一个set的问题吗？<code>mapping</code>方法可以提供一个更加漂亮的解决方案:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;String&gt;&gt; countryToLanguages = locales</span><br><span class="line">        .collect(groupingBy(Locale::getDisplayCountry, mapping(Locale::getDisplayLanguage, toSet())));</span><br></pre></td></tr></table></figure>

<p>如果分组或映射函数的返回值类型是int,long,或double,你可以收集元素到一个统计对象,它在之前章节就出现过.例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, IntSummaryStatistics&gt; stateToCityPopulationSummary = cities</span><br><span class="line">        .collect(groupingBy(City::getState, summarizingInt(City::getPopulation)));</span><br></pre></td></tr></table></figure>

<p>最后,<code>reducing</code>方法可以对downst的元素应用一个聚合函数.它有三种形式:<code>reducing(binaryOperation)</code>,<code>reducing(identity,binaryOperation)</code>和<code>reducing(identity,mapper,binaryOperation)</code>,这其实和<code>reduce</code>的三种形式是对应的.下面是一个获取每个州的所有城市名以逗号分隔的字符串:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; stateToCityNames = cities.collect(groupingBy(City::getState, reducing(<span class="string">&quot;&quot;</span>, City::getName, (s, s2) -&gt; s</span><br><span class="line">        .length() == <span class="number">0</span> ? s2 : s + <span class="string">&quot;,&quot;</span> + s2)));</span><br></pre></td></tr></table></figure>

<p>和<code>reduce</code>一样,<code>reducing</code>用的并不多.这个例子中,我们可以更自然的达到目的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stateToCityNames = cities.collect(groupingBy(City::getState, mapping(City::getName, joining(<span class="string">&quot;,&quot;</span>))));</span><br></pre></td></tr></table></figure>

<p>显然,downstream收集器会产生非常复杂的代码.显然,使用downstream收集器会产生非常复杂的代码.所以,你应该只在处理<code>groupingBy</code>或<code>partitionBy</code>产生的分组的时候使用它们,其他情况,只需要使用诸如<code>map</code>,<code>reduce</code>,<code>count</code>,<code>max</code>或<code>min</code>这些简单的方法即可.</p>
<h2 id="原生类型流"><a href="#原生类型流" class="headerlink" title="原生类型流"></a>原生类型流</h2><p>目前为止,我们都是把整数收集到一个<code>Stream&lt;Integer&gt;</code>,尽管把每个整形放入包装对象显然是低效的做法.其他原始类型也是一样的.为此,Stream API提供了特化类型<code>IntStream</code>,<code>LongStream</code>和<code>DoubleStream</code>,它们直接存储原始类型值,不需要包装.下面是对应关系:</p>
<ul>
<li>存放short、char、byte、int和boolean类型的值,使用<code>IntStream</code></li>
<li>存放float和double类型的值,使用<code>DoubleStream</code>.</li>
<li>存放long类型的值,使用<code>LongStream</code>.</li>
</ul>
<p>要创建一个<code>IntStream</code>,可以调用<code>IntStream.of</code>和<code>Arrays.stream</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">stream = Arrays.stream(values);</span><br></pre></td></tr></table></figure>

<p>和对象流一样,<code>IntStream</code>和<code>LongStream</code>提供了静态方法<code>range</code>和<code>rangeClosed</code>来生成步数为1的数列.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">zeroToNinetyNine</span> <span class="operator">=</span> IntStream.range(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">zeroToHundred</span> <span class="operator">=</span> IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>CharSequnces</code>有两个方法<code>codePoints</code>和<code>chars</code>分别生成Unicode字符的<code>IntStream</code>和UTF-16编码单元的<code>IntStream</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> <span class="string">&quot;\uD835\uDD46 is the set of octonions&quot;</span>;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">codes</span> <span class="operator">=</span> sentence.codePoints();</span><br></pre></td></tr></table></figure>

<p>当你有一个对象流,你可以使用<code>mapToInt</code>,<code>mapToDouble</code>,<code>mapToLong</code>方法把它转换成原生类型流.例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = StreamFactory.stringStream();</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">lengths</span> <span class="operator">=</span> words.mapToInt(String::length);</span><br></pre></td></tr></table></figure>

<p>使用<code>boxed</code>方法把原生类型流转换为对象流:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integers = IntStream.range(<span class="number">0</span>, <span class="number">100</span>).boxed();</span><br></pre></td></tr></table></figure>

<p>一般而言,原生类型流的方法和对象流的方法是类型的,下面是原生类型流和对象流最显著的一些区别:</p>
<ul>
<li>原生类型流的<code>toArray</code>返回原生类型数组,而对象流的<code>toArray</code>方法返回的是对象数组</li>
<li>原生类型流的生成可选结果的方法返回的是<code>OptionalInt</code>、<code>OptionalLong</code>或<code>OptionalDouble</code>.这些类和<code>Optional</code>类相似,但是它们有<code>getAsInt</code>、<code>getAsLong</code>和<code>getAsDouble</code>来代替<code>get</code>方法.</li>
<li>原生类型流有<code>sum</code>,<code>average</code>,<code>max</code>和<code>min</code>方法,对象流没有</li>
<li><code>summaryStatistics</code>方法生成一个类型是<code>IntSummaryStatistics</code>、<code>LongSummaryStatistics</code>和<code>DoubleSummaryStatistics</code>的对象,通过它们可以获取流的总和,平均值,最大值和最小值.</li>
</ul>
<p><code>Random</code>类的<code>ints</code>,<code>longs</code>和<code>doubles</code>方法返回随机数的原生类型流,但要注意,这些流是无限流.</p>
<h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><p>流使对大量运算并行化非常容易.这一过程基本是自动的,但你也需要遵守一些规则.首先,你要有一个并行流.除了<code>Collection.parallelStream</code>方法,流操作生成的都是顺序流.<code>parellel</code>方法可以把任意顺序流转换成并行流.例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; parallelIntegers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>).parallelStream();</span><br><span class="line">Stream&lt;String&gt; parallelWords = Stream.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>).parallel();</span><br></pre></td></tr></table></figure>

<p>只要流是处于并行模式,当执行终结方法的时候,所有的中间流操作都会被并行化.<br>并行化的目的,是希望能得到和顺序执行一样的结果,所以操作必须是无状态和顺序无关,这很重要.<br>下面有一个反例,加上你要计算字符串流中短单词的个数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] shortWords = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; words = Files.lines(Paths.get(<span class="string">&quot;gradlew&quot;</span>))</span><br><span class="line">                                 .flatMap(s -&gt; Arrays.stream(s.split(<span class="string">&quot;[\\P&#123;L&#125;]+&quot;</span>)))) &#123;</span><br><span class="line">    words.parallel().forEach(s -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; <span class="number">12</span>) &#123;</span><br><span class="line">            shortWords[s.length()]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(shortWords));</span><br></pre></td></tr></table></figure>

<p>这是非常糟糕的代码.传递给forEach的函数会在多个线程中并发执行,来更新一个共享的数组,这是典型的竞态条件如果你将这段代码多运行几次,很可能每次都会得到不同的结果,而且没有一个是对的.<br><strong>你需要确保传递给并行流操作的函数式线程安全的</strong>.在我们这个例子中,你可以使用一个<code>AtomicInteger</code>的数组作为计数器,或者使用Stream API提供的方法,对字符串按长度分组再计数.<br>默认情况下,从有序集合(数组或列表),范围值,生成器以及迭代器,或者<code>Stream.sorted</code>所产生的流,都是有序的.对这些流操作的结果也是按照顺序累计的,是完全可预测的.如果你只需相同的操作两次,得到的结果也会是相同的.<br>顺序并不会妨碍并行.例如,当计算<code>stream.map(fun)</code>时,流会分为n块,每一块都会被并行处理,然后在按照顺序将结果组合起来.<br>当不考虑顺序时,某些操作可能会更加高效地并行化.<strong>通过调用<code>stream.unordered</code>方法,你可以表明你不关心顺序</strong>,<code>stream.distinct</code>就是一个可以从中受益的操作.对于有序流,<code>distinct</code>方法会保留所有的相等元素的第一个,这样会阻碍并行,因为处理某块流的线程只有在之前的元素块处理完之后,才知道应该丢弃哪些元素.如果允许保留任意的唯一元素,所有的块都可以并行处理(使用一个共享的set)<br><strong>你还可以通过放弃有序来加快<code>limit</code>方法的速度</strong>.如果你想要一个流中任意n个元素,可以这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; sample = stream.parallel().unordered().limit(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>之前说过,合并map的开销很大,所以,<code>Collectors.groupingByConcurrent</code>使用一个共享的并发map.显然,要从并行计算中获益,map中的值的顺序将无法保证与流中的顺序一致.即使是对于一个有序的流,该收集器也具有无序的天性,因此你<strong>不需要</strong>标记这个流是无序的.但是,你还是需要将流标记为并行模式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;String, List&lt;City&gt;&gt; re = cities.parallel().collect(Collectors.groupingByConcurrent(City::getState));</span><br></pre></td></tr></table></figure>

<p>注意,<strong>当你执行一个流操作的时候,你并不会修改流底层的集合(即使这个操作是线程安全的)</strong>.准确一点说,由于中间流操作是延迟执行的,所以在终结操作执行的之前改变集合是可能的.例如,下面的代码是正确的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(<span class="string">&quot;BEGIN&quot;</span>,<span class="string">&quot;RUNNING&quot;</span>);</span><br><span class="line">words.add(<span class="string">&quot;END&quot;</span>);</span><br><span class="line"><span class="keyword">assert</span> <span class="number">3</span> == words.distinct().count();</span><br></pre></td></tr></table></figure>

<p>但下面的代码是不正确的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">words = wordList.stream();</span><br><span class="line">words.forEach(s -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">7</span>)</span><br><span class="line">        wordList.remove(s);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>在本章中,已经看了很多参数为函数的方法.例如<code>Stream.filter</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>

<p>查看javadoc,发现<code>Predicate</code>是一个函数式接口,只包含一个返回boolean的非默认方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br></pre></td></tr></table></figure>

<p>在实际开发中,一般会传递lambda或者方法引用到<code>filter</code>方法.所以这个方法的名字并不重要,重要的是返回的是boolean值.你在看文档的时候,只要记住<code>Predicate</code>是一个返回boolean值的函数就行.<br>下面的图列举了作为<code>Stream</code>和<code>Collectors</code>方法参数的函数式接口:</p>
<div align="center"><img width="660" height="520" src="https://zjjfly.github.io/images/20170903/java8-2-1.png"/></div>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java-Java8/" rel="tag"># Java Java8</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/07/30/2017-7-30-%E5%BF%AB%E5%AD%A6Java8-%E7%AC%AC%E4%B8%80%E7%AB%A0/" rel="prev" title="快学Java8(第一章)">
      <i class="fa fa-chevron-left"></i> 快学Java8(第一章)
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/09/03/2017-9-3-%E5%BF%AB%E5%AD%A6Java8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%8A/" rel="next" title="快学Java8 第二章上">
      快学Java8 第二章上 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E5%90%88"><span class="nav-number">1.</span> <span class="nav-text">聚合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E7%BB%93%E6%9E%9C"><span class="nav-number">2.</span> <span class="nav-text">收集结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E7%BB%93%E6%9E%9C%E6%94%B6%E9%9B%86%E5%88%B0Map"><span class="nav-number">3.</span> <span class="nav-text">将结果收集到Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E5%92%8C%E5%88%86%E7%89%87"><span class="nav-number">4.</span> <span class="nav-text">分组和分片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B%E6%B5%81"><span class="nav-number">5.</span> <span class="nav-text">原生类型流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="nav-number">6.</span> <span class="nav-text">并行流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.</span> <span class="nav-text">函数式接口</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">JunJie Zi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zjjfly" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zjjfly" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zjjblue@gmail.com" title="E-Mail → mailto:zjjblue@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-fab fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JunJie Zi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
