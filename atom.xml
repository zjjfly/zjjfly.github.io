<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zjjfly&#39;s blog</title>
  
  <subtitle>Java,Clojure,Scala...</subtitle>
  <link href="https://zjjfly.github.io/atom.xml" rel="self"/>
  
  <link href="https://zjjfly.github.io/"/>
  <updated>2023-05-03T02:25:03.439Z</updated>
  <id>https://zjjfly.github.io/</id>
  
  <author>
    <name>JunJie Zi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习Java12~17.md</title>
    <link href="https://zjjfly.github.io/2022/06/21/2022-6-21-%E5%AD%A6%E4%B9%A0Java12-17/"/>
    <id>https://zjjfly.github.io/2022/06/21/2022-6-21-%E5%AD%A6%E4%B9%A0Java12-17/</id>
    <published>2022-06-21T01:32:28.000Z</published>
    <updated>2023-05-03T02:25:03.439Z</updated>
    
    <content type="html"><![CDATA[<p>本文列举了一些从Java12到17的一些比较重要的特性</p><h2 id="switch表达式"><a href="#switch表达式" class="headerlink" title="switch表达式"></a>switch表达式</h2><p>新的<code>switch</code>表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">switch</span> (args[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出有两个变化：</p><ul><li>在匹配成功之后不再需要<code>break</code>来终止继续的匹配</li><li>表达式可以直接给变量赋值</li></ul><span id="more"></span><h2 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h2><p>现在，可以使用使用下面的语法声明一个文本块（多行字符串）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;html&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;Ciao, hello&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;&quot;&quot;&quot;</span>;</span><br><span class="line">Assertions.assertEquals(<span class="string">&quot;&lt;html&gt;\n    &lt;p&gt;Ciao, hello&lt;/p&gt;\n&lt;/html&gt;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用\来防止添加换行符</span></span><br><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1\</span></span><br><span class="line"><span class="string">    2&quot;&quot;&quot;</span>;</span><br><span class="line">Assertions.assertEquals(<span class="string">&quot;12&quot;</span>, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用\s来表示空格</span></span><br><span class="line">s = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1s</span></span><br><span class="line"><span class="string">    2&quot;&quot;&quot;</span>;</span><br><span class="line">Assertions.assertEquals(<span class="string">&quot;1 \n2&quot;</span>, s);</span><br></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;Hello,World&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s &amp;&amp; s.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;string length: &quot;</span> + s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在<code>if</code>表达式有<code>instanceof</code>的判断，那么这之后的逻辑判断和语句块中可以直接把对象作为<code>instanceof</code>的类型参数的对象，不再需要显式的类型转换。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">inputObject</span> <span class="operator">=</span> <span class="number">500L</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedObject</span> <span class="operator">=</span> <span class="keyword">switch</span> (inputObject) &#123;</span><br><span class="line">    <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">    <span class="keyword">case</span> Long l -&gt; String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">    <span class="keyword">case</span> Double d -&gt; String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">    <span class="keyword">case</span> String s -&gt; String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">    <span class="keyword">default</span> -&gt; inputObject.toString();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>17中新加入的预览特性，可以在<code>switch</code>中利用模式匹配来匹配不同类型的对象，实际上和上面的<code>instanceof</code>的模式匹配左右类型，都是为了避免显式的类型转换。因为是预览特性，所以需要在编译和运行的时候加上参数<code>--enable-preview</code>。</p><h2 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="comment">//可以使用下面的语法给默认的构造函数加一些额外的逻辑</span></span><br><span class="line">    Person &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;age must be greater than zero!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;foo&quot;</span>, <span class="number">32</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">System.out.println(<span class="string">&quot;person.name() = &quot;</span> + person.name());</span><br><span class="line">System.out.println(<span class="string">&quot;person.age() = &quot;</span> + person.age());</span><br></pre></td></tr></table></figure><p>类似Scala的case class,在类名后直接跟默认的构造函数参数，这些参数也是这个类的字段，且是不可变的。编译器还会添加访问字段的方法和默认的toString,equals,hasCode等方法。</p><h3 id="sealed-class"><a href="#sealed-class" class="headerlink" title="sealed class"></a>sealed class</h3><p>sealed class表示这个类只能有某些指定的子类，未被批准的子类是不允许的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">LineShape</span> <span class="keyword">permits</span> Rectangle, Square, Triangle &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">LineShape</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">non-sealed</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">LineShape</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">LineShape</span> <span class="keyword">permits</span> ColorSquare &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ColorSquare</span> <span class="keyword">extends</span> <span class="title class_">Square</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>sealed class的子类必须是final,sealed或者non-sealed修饰的</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>Java17恢复了默认使用严格浮点数，之前的版本需要使用<code>strictfp</code>关键字显式声明</li><li>引入了新的随机数生成的接口<code>RandomGenerator</code>，这样可以把API和具体实现分开，并且不改变现有的Random类。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文列举了一些从Java12到17的一些比较重要的特性&lt;/p&gt;
&lt;h2 id=&quot;switch表达式&quot;&gt;&lt;a href=&quot;#switch表达式&quot; class=&quot;headerlink&quot; title=&quot;switch表达式&quot;&gt;&lt;/a&gt;switch表达式&lt;/h2&gt;&lt;p&gt;新的&lt;code&gt;switch&lt;/code&gt;表达式：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (args[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以看出有两个变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在匹配成功之后不再需要&lt;code&gt;break&lt;/code&gt;来终止继续的匹配&lt;/li&gt;
&lt;li&gt;表达式可以直接给变量赋值&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Java Java12 Java13 Java14 Java15 Java16 Java17" scheme="https://zjjfly.github.io/tags/Java-Java12-Java13-Java14-Java15-Java16-Java17/"/>
    
  </entry>
  
  <entry>
    <title>Python Tricks之简洁之道</title>
    <link href="https://zjjfly.github.io/2019/07/18/2019-7-10-Python-Tricks%E4%B9%8B%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    <id>https://zjjfly.github.io/2019/07/18/2019-7-10-Python-Tricks%E4%B9%8B%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93/</id>
    <published>2019-07-18T01:32:28.000Z</published>
    <updated>2023-05-03T02:19:42.013Z</updated>
    
    <content type="html"><![CDATA[<p>这是”Python Tricks”一书的读书笔记.什么是Python Tricks?就是一小段Python代码,它既传授了Python语言的一个特性,也是一个让你深入发掘这一特性的驱动力.</p><p>本文是该书第二章”写出更简洁的Python”的读书笔记.这里的简洁不止意味的代码量的少,还是指不需要加很多注释就可以让别人看懂,即可读性高.</p><span id="more"></span><h2 id="善用assert"><a href="#善用assert" class="headerlink" title="善用assert"></a>善用assert</h2><p>有的时候一个很有用的语言特性会得不到特别多的关注,Python的<code>assert</code>就是一个例子.它是一个dubug的帮手,可以测试一个条件表达式.如果表达式的结果为真,什么事都不会发生;如果表达式为假,程序会抛出一个<code>AssertionError</code>的异常.</p><h3 id="一个assert的例子"><a href="#一个assert的例子" class="headerlink" title="一个assert的例子"></a>一个assert的例子</h3><p>来看一个计算商品打折后的价格的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_discount</span>(<span class="params">product, discount</span>):</span><br><span class="line">    price = <span class="built_in">int</span>(product[<span class="string">&#x27;price&#x27;</span>] * (<span class="number">1.0</span> - discount))</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt; price &lt; product[<span class="string">&#x27;price&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> price</span><br></pre></td></tr></table></figure><p>这段代码中的<code>assert</code>保证了打折后的价格不会低于0,也不会高于商品的原来的价格.使用代码测试一下.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoes = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Fancy Shoes&#x27;</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">14900</span>&#125;</span><br><span class="line">apply_discount(shoe,<span class="number">0.25</span>)</span><br></pre></td></tr></table></figure><p>最后的输出是<code>11175</code>,符合预期.再故意使用一个错误的折扣来测试.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply_discount(shoe,<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>程序会报错:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:/WorkSpace/PythonTricks/ch2/assert.py&quot;, line 10, in &lt;module&gt;</span><br><span class="line">    apply_discount(shoes, 2.0)</span><br><span class="line">  File &quot;D:/WorkSpace/PythonTricks/ch2/assert.py&quot;, line 3, in apply_discount</span><br><span class="line">    assert 0 &lt; price &lt; product[&#x27;price&#x27;]</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure><p>使用<code>assert</code>的好处是可以更快速的debug,而且从长远来看它会让你的代码更容易维护.</p><h3 id="为什么不使用一般的异常"><a href="#为什么不使用一般的异常" class="headerlink" title="为什么不使用一般的异常"></a>为什么不使用一般的异常</h3><p>为什么不使用<code>if-else</code>并抛出一个一般的异常呢?因为<code>assert</code>告知开发人员出现了不可恢复的错误,而不是那些可以预估到的错误,如文件不存在这样的错误.</p><p><code>assert</code>用于程序内部的自省,它断言一些条件是不可能的,如果这些条件有一个不满足,那就说明你的代码是有bug的,你就可以很快的通过报错信息来定位出错的代码.这条准则同样适用于其他语言.但记住,<strong>断言错误永远不应该出现,除非你的程序有bug</strong>.</p><h3 id="assert的语法"><a href="#assert的语法" class="headerlink" title="assert的语法"></a>assert的语法</h3><p>根据Python的文档,<code>assert</code>语法是这样的:</p><blockquote><p>assert_stmt ::&#x3D; “assert” expression1 [“,” expression2]</p></blockquote><p>其中<code>expression</code>是一个条件表达式,<code>expression2</code>是可选的自定义错误信息.</p><p>Python解释器会把<code>assert</code>表达式转换成下面的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">__debug__</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> expression1:</span><br><span class="line"><span class="keyword">raise</span> AssertionError(expression2)</span><br></pre></td></tr></table></figure><p>可以看出,全局变量<code>__debug__</code>决定了<code>assert</code>是否起作用,一般情况下这个变量都是<code>True</code>的.</p><h3 id="assert的陷阱"><a href="#assert的陷阱" class="headerlink" title="assert的陷阱"></a>assert的陷阱</h3><p>1.不要把<code>assert</code>用于数据验证.因为<code>assert</code>可以通过命令行参数<code>-O</code>和<code>-OO</code>,或是环境变量<code>PYTHONOPTIMIZE</code>来禁用.如果你的代码使用<code>assert</code>来检查方法的参数是否包含错误的或不符合预期的参数,那么就会产生bug或安全漏洞.</p><p>举个例子,你写了一个删除商品的方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delete_product</span>(<span class="params">prod_id, user</span>):</span><br><span class="line"><span class="keyword">assert</span> user.is_admin(), <span class="string">&#x27;Must be admin&#x27;</span></span><br><span class="line"><span class="keyword">assert</span> store.has_product(prod_id), <span class="string">&#x27;Unknown product&#x27;</span></span><br><span class="line">store.get_product(prod_id).delete()</span><br></pre></td></tr></table></figure><p>当<code>assert</code>禁用时,会出现两个问题:</p><ul><li>任何用户都可以删除商品</li><li>黑客可以通过DDOS来攻击,导致服务器宕机</li></ul><p>怎么解决这个问题,那就是不用<code>assert</code>来验证,而是用一般的<code>if</code>表达式并在必要的时候抛出验证错误.就像这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delete_product</span>(<span class="params">product_id, user</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> user.is_admin():</span><br><span class="line"><span class="keyword">raise</span> AuthError(<span class="string">&#x27;Must be admin to delete&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> store.has_product(product_id):</span><br><span class="line"><span class="keyword">raise</span> ValueError(<span class="string">&#x27;Unknown product id&#x27;</span>)</span><br><span class="line">store.get_product(product_id).delete()</span><br></pre></td></tr></table></figure><p>这样写的还有一个好处是,相比断言错误,这里抛出的自定义的异常在语义上更加正确.</p><p>2.永远不会失败的断言.如果你想要抛出<code>AssertError</code>的时候显示一些自定义信息,那么你可以在布尔表达式后面加一个字符串,但这种写法有一个陷阱,如果你不小心用括号把这两个参数包了起来,那么这个断言就永远是<code>True</code>的.例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="number">1</span> == <span class="number">2</span>, <span class="string">&#x27;This should fail&#x27;</span>)</span><br></pre></td></tr></table></figure><p>原因是实际上这里的条件表达式变为了一个tuple,而tuple作为一个条件表达式永远是<code>True</code>的.这种写法在Python3中会导致一个语法告警,所以不再那么容易出现了.</p><h2 id="充足的逗号"><a href="#充足的逗号" class="headerlink" title="充足的逗号"></a>充足的逗号</h2><p>当你在dict,list和set常量中添加删除元素的时候,建议你在每一个行的末尾都加上逗号.</p><p>你可能一下子不明白我在说啥?看一个例子,假设你的代码中有下面这样的一个list:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Dilbert&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果你修改了其中一个元素,那么在版本控制系统中很难看出你改的内容,特别是当这个list的元素比较多的时候,因为版本控制系统如Git都是基于行的.</p><p>一种更好的代码风格是这样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [</span><br><span class="line"><span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Dilbert&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>每个元素一行,这样在版本控制系统中看代码的diff的时候很容易就知道加了新增,删除或修改了哪些元素.</p><p>但这样写还有一个问题,就是当你新增或删除元素的时候,需要手动的修改逗号的位置,比如在这个list后面再加一个元素,你需要在<code>&#39;Dilbert&#39;</code>后加一个逗号.这样很容易因为忘记修改逗号导致bug.比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = [</span><br><span class="line"><span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Dilbert&#x27;</span> <span class="comment"># 漏加了一个逗号</span></span><br><span class="line">    <span class="string">&#x27;Jane&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这个list的打印结果是:</p><blockquote><p>[‘Alice’, ‘Bob’, ‘DilbertJane’]</p></blockquote><p>Python把最后两行的字符串合并成了一个字符串.这被称为<code>字符串字面量拼接</code>.这是文档中明确说明的一种行为.它在有些情况下很管用,但也容易引起问题.</p><p>回到上面的代码,要解决这个bug只要加上缺失的逗号就行了,但这样每加一个元素都需要改两行代码显然是件麻烦的事情.解决的办法就是在每一个元素后都加逗号,包括最后一个元素,这种写法在Python中是合法的.</p><p>所以<code>names</code>这个list最好的写法是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [</span><br><span class="line"><span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Dilbert&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="上下文管理器和with表达式"><a href="#上下文管理器和with表达式" class="headerlink" title="上下文管理器和with表达式"></a>上下文管理器和<code>with</code>表达式</h2><p>对一些开发者来说,<code>with</code>被认为是一个很复杂的特性.但如果你一窥它的实质,你会发现其中没有什么魔法,而只是一个语法糖.<br>看一个比较常见的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;hello.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">f.write(<span class="string">&#x27;hello, world!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这段代码在运行的时候会被转换成下面这样的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;hello.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">f.write(<span class="string">&#x27;hello, world&#x27;</span>) </span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>其中的<code>try</code>和<code>finally</code>是必须的,因为这样写才能保证文件的descriptor最终会被释放,但这样写的不好的地方是比较啰嗦.而如果使用<code>with</code>,代码就简洁了不少.</p><p>在看一个使用<code>with</code>的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_lock = threading.Lock()</span><br><span class="line"><span class="keyword">with</span> some_lock:</span><br><span class="line"><span class="comment"># Do something...</span></span><br></pre></td></tr></table></figure><p>在这两个例子中,<code>with</code>都让你把大多数对资源的处理的逻辑抽象出来.相比于冗长的<code>try...finally</code>,仅仅使用<code>with</code>就可以为你处理这些.</p><p><code>with</code>不止可以提高处理系统资源相关的代码的可读性,还可以让忘记清理或释放不再需要的资源这种事情变得几乎不可能,这也避免了bug和泄露.</p><h3 id="让自定义类型支持with"><a href="#让自定义类型支持with" class="headerlink" title="让自定义类型支持with"></a>让自定义类型支持<code>with</code></h3><p>只要你的类实现了context manager,它就可以使用<code>with</code>声明.什么是context manager?它其实是一个简单的协议,只要类中有<code>__enter__</code>和<code>__exit__</code>这两个方法,它就算是context manager了.Python会在资源管理周期的适当时候调用它们.</p><p>现在试着自己实现类似open()的功能:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ManagedFile</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        self.file = <span class="built_in">open</span>(self.name, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.file</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close()</span><br></pre></td></tr></table></figure><p>使用它:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ManagedFile(<span class="string">&#x27;hello.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(<span class="string">&#x27;hello, world!&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;bye now&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Python会在进入<code>with</code>声明的上下文的时候调用<code>__enter__</code>方法来获取资源,在离开这个上下文的时候调用<code>__exit__</code>方法来是否资源.</p><p>写一个基于类的context manager并不是Python中唯一的支持<code>with</code>声明的方法.还有另一种方法,在标准库中的<code>contextlib</code>模块提供了一些建立于context manager协议之上的抽象.<br>如果你的使用场景适合,它可以让你更容易的支持<code>with</code>.</p><p>比如,你可以使用<code>contextlib.contextmanager</code>注解来标注一个基于生成器的资源工厂方法,然后这个方法就会自动支持<code>with</code>声明了.我们试着用这种方法重新实现<code>ManagedFile</code>这个例子.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">managed_file</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        file = <span class="built_in">open</span>(name, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> file</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        file.close()</span><br></pre></td></tr></table></figure><p><code>managed_file</code>是一个生成器,它首先获取资源,然后它使用yield阻塞方法的继续执行并把资源返回给调用者.当调用者离开<code>with</code>,生成器会继续执行以便进行对资源的清理工作,资源就可以被释放.</p><p>这两种方法本质上是等价的,你可以选择适合你情况的,主要取决于你的团队的习惯以及哪种方法的可读性更好.</p><h3 id="使用context-manager写出更漂亮的API"><a href="#使用context-manager写出更漂亮的API" class="headerlink" title="使用context manager写出更漂亮的API"></a>使用context manager写出更漂亮的API</h3><p>实际上context manager不止能用于资源管理,它的灵活性很高,你可以用它写便利的API.<br>比如,你要写一个报表生成程序,需要处理文本缩进.想要达到这样的效果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Indent() <span class="keyword">as</span> indent:</span><br><span class="line">    indent.<span class="built_in">print</span>(<span class="string">&#x27;hi!&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> indent:</span><br><span class="line">        indent.<span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> indent:</span><br><span class="line">            indent.<span class="built_in">print</span>(<span class="string">&#x27;bonjour&#x27;</span>)</span><br><span class="line">    indent.<span class="built_in">print</span>(<span class="string">&#x27;hey&#x27;</span>)</span><br></pre></td></tr></table></figure><p>预期的输出:</p><blockquote><p>hi!<br/><br>&amp;emsp;&amp;emsp;hello<br/><br>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;bonjour<br/><br>hey</p></blockquote><p>这样的API读着很像DSL,基本做到了代码即结果,你看代码就很容易知道它运行的结果,可读性很高.下面是<code>Indent</code>的实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Indent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.indentSize = <span class="number">0</span></span><br><span class="line">        self.entered = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.entered:</span><br><span class="line">            self.indentSize += <span class="number">1</span></span><br><span class="line">        self.entered = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="keyword">if</span> self.indentSize:</span><br><span class="line">            self.indentSize -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self, s</span>):</span><br><span class="line">        indent_str = <span class="string">&#x27;\t&#x27;</span> * self.indentSize</span><br><span class="line">        <span class="built_in">print</span>(indent_str, s)</span><br></pre></td></tr></table></figure><h2 id="下划线-dunders和其他"><a href="#下划线-dunders和其他" class="headerlink" title="下划线,dunders和其他"></a>下划线,dunders和其他</h2><p>单下划线或双下划线在Python的变量名或方法名中很常见.它们实际是有一些含义的,其中一些只是约定俗成的习惯(如本地变量名使用单下划线分隔不同的单词,即snake case),还有一些则是Python解释器强制规定的.</p><p>你肯定会好奇单下划线和双下划线分别代表什么含义,接下来就会介绍五种下划线的模式和命名习惯以及它们是如何影响Python程序的行为的.</p><h3 id="单下划线开头-”-var”"><a href="#单下划线开头-”-var”" class="headerlink" title="单下划线开头:”_var”"></a>单下划线开头:”_var”</h3><p>以这样的方法命名变量或方法,仅仅是一种Python社区的习惯.它对于程序员是一个暗示:这个变量或方法只在类的内部使用.这个惯例在PEP 8(最常用的Python编码规范)中有明确的规定.</p><p>但这种写法并不是Python解释器强制规定的,Python并没有像Java那样,<code>private</code>和<code>public</code>变量有着很大的区别.它就像是一个警告标志,告诉程序员不要把这个变量或方法当成这个类的公共接口的一部分.<br>例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.foo = <span class="number">11</span></span><br><span class="line">        self._bar = <span class="number">23</span></span><br></pre></td></tr></table></figure><p>如果你实例化了这个类并访问<code>foo</code>和<code>_bar</code>属性会怎么样?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test = Test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;foo:%d&quot;</span> % test.foo)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;_bar:%d&quot;</span> % test._bar)</span><br></pre></td></tr></table></figure><p>运行结果:</p><blockquote><p>foo:11<br/><br>_bar:23</p></blockquote><p>所以,开头的下划线没有阻止<code>_bar</code>被外部代码访问,这只是一种编程规范.</p><p>但它确实会影响模块的导入.如果你使用wildcard import(import *)导入一个含有名称以单下划线开头的函数或变量的模块,那么这些单下划线开头的函数或变量不会被导入.<br>例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">external_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_internal_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br></pre></td></tr></table></figure><p>在另一个Python文件中导入这个模块:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> *</span><br><span class="line">external_func()</span><br><span class="line">_internal_func()</span><br></pre></td></tr></table></figure><p>输出结果:</p><blockquote><p>23<br/><br>NameError: “name ‘_internal_func’ is not defined”</p></blockquote><p>但如果你遵守PEP 8,那么wildcard import并不是推荐的做法,使用一般的import更好.一般的import也不会发生这种以下划线开头的字段没有被导入的情况.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line">my_module.external_func()</span><br><span class="line">my_module._internal_func()</span><br></pre></td></tr></table></figure><p>输出结果:</p><blockquote><p>23<br/><br>42</p></blockquote><h3 id="单下划线结尾-”var-”"><a href="#单下划线结尾-”var-”" class="headerlink" title="单下划线结尾:”var_”"></a>单下划线结尾:”var_”</h3><p>有的时候,你觉得最适合这个方法或变量的单词已经被Python用作关键字了.所以像<code>class</code>,<code>def</code>不能作为变量的名称.这种情况下,你可以在这些词后面加一个下划线避免命名冲突.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_object</span>(<span class="params">name, class_</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>总之,以单下划线结尾这种命名方式是用于防止命名冲突的,这个惯例也是在PEP 8中规定的.</p><h3 id="双下划线开头-”-var”"><a href="#双下划线开头-”-var”" class="headerlink" title="双下划线开头:”__var”"></a>双下划线开头:”__var”</h3><p>之前的命名模式都只是一种编程惯例,但类中以双下划线开头的方法或变量就不一样了.这种写法会使解释器对它的名称重写以防止子类中的命名冲突.这种做法被称为名称重整(name mangling).</p><p>例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.foo = <span class="number">11</span></span><br><span class="line">        self._bar = <span class="number">23</span></span><br><span class="line">        self.__baz = <span class="number">23</span></span><br></pre></td></tr></table></figure><p>用<code>dir()</code>来看看这个类的实例中的成员:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = Test()</span><br><span class="line"><span class="built_in">dir</span>(t)</span><br></pre></td></tr></table></figure><blockquote><p>[‘_Test__baz’, ‘__class__‘, ‘__delattr__‘, ‘__dict__‘, ‘__dir__‘, ‘__doc__‘, ‘__eq__‘, ‘__format__‘, ‘__ge__‘,’__getattribute__‘, ‘__gt__‘, ‘__hash__‘, ‘__init__‘, ‘__init_subclass__‘, ‘__le__‘, ‘__lt__‘, ‘__module__‘, ‘__ne__‘,’__new__‘, ‘__reduce__‘, ‘__reduce_ex__‘, ‘__repr__‘, ‘__setattr__‘, ‘__sizeof__‘, ‘__str__‘, ‘__subclasshook__‘,’__weakref__‘, ‘_bar’, ‘foo’]</p></blockquote><p>可以看出,<code>__baz</code>这个变量的名称被改为了<code>_Test__baz</code>.这是解释器的一种叫做名称重整的行为.这样做是为了防止这个变量被子类覆盖.</p><p>可以尝试写一个类来继承<code>Test</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendedTest</span>(<span class="title class_ inherited__">Test</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.foo = <span class="string">&#x27;overridden&#x27;</span></span><br><span class="line">        self._bar = <span class="string">&#x27;overridden&#x27;</span></span><br><span class="line">        self.__baz = <span class="string">&#x27;overridden&#x27;</span></span><br><span class="line"></span><br><span class="line">t2 = ExtendedTest()</span><br><span class="line">t2.foo</span><br><span class="line">t2._bar</span><br><span class="line">t2.__baz</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>overridden<br/><br>overridden<br/><br>AttributeError:”‘ExtendedTest’ object has no attribute ‘__baz’”</p></blockquote><p>为什么会报错?因为又发生了名称重整:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>(t2)</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>[‘_ExtendedTest__baz’, ‘_Test__baz’, ‘__class__‘, ‘__delattr__‘, ‘__dict__‘, ‘__dir__‘, ‘__doc__‘, ‘__eq__‘, ‘__format__‘, ‘__ge__‘, ‘__getattribute__‘, ‘__gt__‘, ‘__hash__‘, ‘__init__‘, ‘__init_subclass__‘, ‘__le__‘, ‘__lt__‘, ‘__module__‘, ‘__ne__‘, ‘__new__‘, ‘__reduce__‘, ‘__reduce_ex__‘, ‘__repr__‘, ‘__setattr__‘, ‘__sizeof__‘, ‘__str__‘, ‘__subclasshook__‘, ‘__weakref__‘, ‘_bar’, ‘foo’]</p></blockquote><p>可以看到, <code>ExtendedTest</code>的 <code>__baz</code>变成了<code>_ExtendedTest__baz</code>.而且父类的<code>_Test__baz</code>也仍然存在.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t2._Test__baz</span><br><span class="line">t2._ExtendedTest__baz</span><br></pre></td></tr></table></figure><p>名称重整对程序员来说是完全透明的.看一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ManglingTest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.__mangled = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_mangled</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__mangled</span><br><span class="line"></span><br><span class="line">mt = ManglingTest()</span><br><span class="line">mt.get_mangled()</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>hello</p></blockquote><p>可以看出,在类内部访问以双引号开头的变量<code>__mangled</code>,是不需要知道它经过重整后的名字的.</p><p>名称重整也会作用于方法.例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MangledMethod</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_it</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__method()</span><br><span class="line"></span><br><span class="line">mm = MangledMethod()</span><br><span class="line">mm.call_it()</span><br><span class="line">mm.__method()</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>42<br/><br>AttributeError: ‘MangledMethod’ object has no attribute ‘__method’</p></blockquote><p>可以看出,因为名称重整,<code>MangledMethod</code>不存在名为<code>__method</code>的成员了.</p><p>下面看一个会让人惊讶的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_MangledGlobal__mangled = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MangledGlobal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> __mangled</span><br><span class="line"></span><br><span class="line">MangledGlobal().test()</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>11</p></blockquote><p><code>_MangledGlobal__mangled</code>是一个全局变量,但在<code>MangledGlobal</code>的内部,居然通过<code>__mangled</code>就可以访问它.显然,名称重整在其中又起了作用.这个例子显示了名称重整针对的是类中出现的所有以双下划线开头的变量,而不只是内的成员变量.</p><h3 id="啥是dunders"><a href="#啥是dunders" class="headerlink" title="啥是dunders?"></a>啥是dunders?</h3><p>如果你曾听过一些Python老鸟讨论Python或一些Python相关的演讲,你可能听到过这个单词:<code>dunder</code>.你肯定会疑惑这个单词时啥意思.</p><p>其实答案很简单:这是Python社区对<code>double underscore</code>的称呼.原因是双下滑线在Python中很常见,以至于如果总是使用英文<code>double underscore</code>称呼它会让你下巴脱臼,所以使用了这么一个缩写来指代它.例如,<code>__baz</code>读作”dunder  baz”,<code>__init__</code>读作”dunder init”. </p><h3 id="前后双下划线-”-var-“"><a href="#前后双下划线-”-var-“" class="headerlink" title="前后双下划线:”__var__“"></a>前后双下划线:”__var__“</h3><p>说起来可能会让你惊讶,名称重整不会作用于名称以双下划线开头和结尾的变量.例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrefixPostfixTest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.__bam__ = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">PrefixPostfixTest().__bam__</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>42</p></blockquote><p>但是,在Python中以双下划线开头和结尾的名称是被保留做特殊用途的.比如<code>__init__</code>用于对象构造器,<code>__call__</code>是对象可以像方法一样调用.这些方法被称为”dunder methods”或”magic methods”,但后者并不合适,它会让人觉得使用这些方法并不被鼓励(就像magic number),而实际情况并非如此.它们是Python语言的核心要素,在必要的时候就应该使用它们.它们没有什么神奇的或难懂的东西.</p><p>我们还是要<strong>避免使用这种命名模式</strong>,因为这可能让你的代码和未来的Python版本发生冲突.</p><h3 id="单下划线-”-”"><a href="#单下划线-”-”" class="headerlink" title="单下划线:”_”"></a>单下划线:”_”</h3><p>单个下划线作为变量名,说明这个变量是临时的或无足轻重的,给它一个名称没什么意义,所以就是简单的用<code>_</code>来为它命名.</p><p>例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello,World&#x27;</span>)</span><br></pre></td></tr></table></figure><p>还可以在解包的时候用<code>_</code>表示一个你不关心的变量.这只是一个命名习惯,不会触发任何解释器的行为.<code>_</code>仅仅是一个有效的变量名.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">car = (<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>, <span class="number">12</span>, <span class="number">3812.4</span>)</span><br><span class="line">color, _, _, mileage = car</span><br><span class="line">color</span><br><span class="line">mileage</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>red<br/><br>3812.4</p></blockquote><p>在大多数Python REPL中,<code>_</code>还表示最近一个表达式的结果.</p><h2 id="关于字符串格式化的惊人事实"><a href="#关于字符串格式化的惊人事实" class="headerlink" title="关于字符串格式化的惊人事实"></a>关于字符串格式化的惊人事实</h2><p>在著名的&lt;&lt;Python之禅&gt;&gt;中,有一句是说”应该有一个明确的方式去完成某件事”.但事实上,Python中却有四种方法可以对字符串进行格式化!</p><p>先定义两个变量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">errno = <span class="number">50159747054</span></span><br><span class="line">name = <span class="string">&#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure><p>我们想要基于这两个变量来生成一个字符串:</p><blockquote><p>Hey Bob, there is a 0xbadc0ffee error!</p></blockquote><p>接下来会分别使用四种方式来完成这个任务,同时对它们的优点和缺点逐一介绍,并阐述选取最合适的字符串格式化方式的经验准则.</p><h3 id="“旧式”的字符串格式化"><a href="#“旧式”的字符串格式化" class="headerlink" title="“旧式”的字符串格式化"></a>“旧式”的字符串格式化</h3><p>Python的字符串有一个独特的内置操作,通过操作符<code>%</code>调用.它是一个进行基于位置的格式化的快捷操作.类似于C中的<code>printf</code>.例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Hello, %s&#x27;</span> % name</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>Hello,Bob</p></blockquote><p>其中的<code>%s</code>是格式声明符,它会告诉Python在字符串的什么位置替换为<code>name</code>的值,以字符串的形式.还有很多其他的格式声明符可以用来控制输出的格式,比如有的可以把数字转换成16进制表示或填充空格来生成格式漂亮的表和报告.</p><p><code>%x</code>就可以把int类型的值转成string并以16进制表示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="string">&#x27;%x&#x27;</span> % errno</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>badc0ffee</p></blockquote><p>如果你想要对单个字符串进行多次替换,你需要把这多个参数放到一个元组中,因为<code>%</code>只接收一个参数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Hey %s, there is a 0x%x error!&#x27;</span> % (name, errno)</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>Hey Bob, there is a 0xbadc0ffee error!</p></blockquote><p>你还可以在格式化字符中通过名称来指向替换变量,这种情况传递给<code>%</code>的参数是一个名称和遍历的映射关系.例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Hey %(name)s, there is a 0x%(errno)x error!&#x27;</span> % &#123;<span class="string">&quot;name&quot;</span>: name, <span class="string">&quot;errno&quot;</span>: errno&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>Hey Bob, there is a 0xbadc0ffee error!</p></blockquote><p>这种方式会让你的代码更容易维护和修改,因为你不需要关系传入的值的顺序是否和格式化字符串中的一致.当然,它的缺点是会增加代码量.</p><h3 id="“新式”的字符串格式化"><a href="#“新式”的字符串格式化" class="headerlink" title="“新式”的字符串格式化"></a>“新式”的字符串格式化</h3><p>Python3引入了一种新的字符串格式化的方式,它后来还被移植到了2.7中.新的方式摆脱了奇怪的<code>%</code>符号,使得字符串的格式化更加标准.格式化现在只要对字符串对象调用<code>format</code>方法就可以了.例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;Hello,&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name)</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>Hello,Bob</p></blockquote><p>这种方法同样可以在格式化字符中通过名称来指向替换变量.例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Hey &#123;name&#125;, there is a 0x&#123;errno:x&#125; error!&#x27;</span>.<span class="built_in">format</span>(name=name, errno=errno)</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>Hey Bob, there is a 0xbadc0ffee error!</p></blockquote><p>这也展示了如何格式化一个int值为十六进制的字符串,只需要在字符串中的变量名后加一个<code>:x</code>后缀.</p><p>在Python3中,这种方式比旧式的更受人喜欢,但从Python3.6开始,有了一种更好的格式化字符串的方法.</p><h3 id="字符串字面量插入-Python3-6"><a href="#字符串字面量插入-Python3-6" class="headerlink" title="字符串字面量插入(Python3.6+)"></a>字符串字面量插入(Python3.6+)</h3><p>Python3.6加入加入了一种叫做格式化字符串字面量的方法.这种格式化字符串的方法让我们可以再字符串常量中加入内嵌的表达式.一个简单的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">f&#x27;Hello,<span class="subst">&#123;name&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure><p>这种方法非常强大,因为你可以嵌入任何的表达式,包括算术运算.例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">f&#x27;Five plus ten is <span class="subst">&#123;a + b&#125;</span> and not <span class="subst">&#123;<span class="number">2</span> * (a + b)&#125;</span>.&#x27;</span></span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>Five plus ten is 15 and not 30.</p></blockquote><p>在底层,格式化字符串字面量是Python解释器的一项特性,它会把这些f开头的字符串转换成字符串常量和表达式,然后把他们拼接起来来组成最终的字符串.</p><p>一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name, question</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>! How&#x27;s it <span class="subst">&#123;question&#125;</span>?&quot;</span></span><br></pre></td></tr></table></figure><p>把这个函数反汇编,你可以看到这个函数被转换成了类似下面的形式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name, question</span>):</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;! How&#x27;s it &quot;</span> + question + <span class="string">&quot;?&quot;</span>)</span><br></pre></td></tr></table></figure><p>当然,实际的实现方式更搞笑,它使用了<code>BUILD_STRING</code>这个opcode(Python源代码编译之后的格式,类似Java字节码)作为优化.但它们最终的效果是一样的.</p><p>它也支持和<code>format</code>方法类似的格式化语法.例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">f&quot;Hey <span class="subst">&#123;name&#125;</span>, there is a <span class="subst">&#123;errno:#x&#125;</span> error!&quot;</span></span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>Hey Bob, there is a 0xbadc0ffee error!</p></blockquote><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>还有一个字符串格式化的方式是模板字符串,这种方式更简单,但没那么强大.有些情况使用它还是非常合适的.</p><p>例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line">t = Template(<span class="string">&#x27;Hello,$name&#x27;</span>)</span><br><span class="line">t.substitute(name=name)</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>Hello,Bob</p></blockquote><p>可以看到使用模板字符串需要导入<code>Template</code>这个类.它不是Python的一个核心语言特性,但它存在于标准库中.</p><p>另一个区别是,它不支持格式化声明符.所以需要我们自己把int转换成十六进制的字符串.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">templ_string = <span class="string">&#x27;Hey $name, there is a $error error!&#x27;</span></span><br><span class="line">Template(templ_string).substitute(name=name, error=<span class="built_in">hex</span>(errno))</span><br></pre></td></tr></table></figure><p>什么时候使用这个方法呢?一般来说,如果格式化字符串是用户自己输入的,那么可以使用这个方法,因为它更加安全.看一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECRET = <span class="string">&#x27;this-is-a-secret&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Error</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">err = Error()</span><br><span class="line">user_input = <span class="string">&#x27;&#123;error.__init__.__globals__[SECRET]&#125;&#x27;</span></span><br><span class="line">user_input.<span class="built_in">format</span>(error=err)</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>this-is-a-secret</p></blockquote><p>可以看到,攻击者可以拿到<code>SECRET</code>这个字符串的,这是一个安全漏洞.而模板字符串可以避免这个问题.</p><p>例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_input = <span class="string">&#x27;$&#123;error.__init__.__globals__[SECRET]&#125;&#x27;</span></span><br><span class="line">Template(user_input).substitute(error=err)</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>ValueError:”Invalid placeholder in string: line 1, col 1”</p></blockquote><h3 id="怎么选择格式化字符串的方式"><a href="#怎么选择格式化字符串的方式" class="headerlink" title="怎么选择格式化字符串的方式"></a>怎么选择格式化字符串的方式</h3><p>有一个简单的规则:如果需要格式化的字符串是用户提供的,那么使用模板字符串来避免安全问题.否则,使用格式化字符串字面量如果是在Python3.6及以上版本,使用字符串的<code>format</code>的方法如果是在较旧的版本.</p><h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h2><p>只要是Python的书,基本绕不开Tim Peter的&lt;&lt;Python之禅&gt;&gt;.这首诗让人受益良多,历久弥新.它可以让我们成为一个更好的程序员,因为它里面的这些道理适用于几乎所有编程语而不局限于Python.</p><p>Python中有一个关于它的彩蛋,在Python REPL中输入下面的指令:</p><blockquote><p>import this</p></blockquote><p>&lt;&lt;Python之禅&gt;&gt;就会被打印出来:</p><blockquote><p>The Zen of Python, by Tim Peters<br/><br><br/><br>Beautiful is better than ugly.<br/><br>Explicit is better than implicit.<br/><br>Simple is better than complex.<br/><br>Complex is better than complicated.<br/><br>Flat is better than nested.<br/><br>Sparse is better than dense.<br/><br>Readability counts.<br/><br>Special cases aren’t special enough to break the rules.<br/><br>Although practicality beats purity.<br/><br>Errors should never pass silently.<br/><br>Unless explicitly silenced.<br/><br>In the face of ambiguity, refuse the temptation to guess.<br/><br>There should be one– and preferably only one –obvious way to do it.<br/><br>Although that way may not be obvious at first unless you’re Dutch.<br/><br>Now is better than never.<br/><br>Although never is often better than <em>right</em> now.<br/><br>If the implementation is hard to explain, it’s a bad idea.<br/><br>If the implementation is easy to explain, it may be a good idea.<br/><br>Namespaces are one honking great idea – let’s do more of those!</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是”Python Tricks”一书的读书笔记.什么是Python Tricks?就是一小段Python代码,它既传授了Python语言的一个特性,也是一个让你深入发掘这一特性的驱动力.&lt;/p&gt;
&lt;p&gt;本文是该书第二章”写出更简洁的Python”的读书笔记.这里的简洁不止意味的代码量的少,还是指不需要加很多注释就可以让别人看懂,即可读性高.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python Tricks" scheme="https://zjjfly.github.io/tags/Python-Tricks/"/>
    
  </entry>
  
  <entry>
    <title>学习Java9~11</title>
    <link href="https://zjjfly.github.io/2019/05/29/2019-5-29-%E5%AD%A6%E4%B9%A0Java9-11/"/>
    <id>https://zjjfly.github.io/2019/05/29/2019-5-29-%E5%AD%A6%E4%B9%A0Java9-11/</id>
    <published>2019-05-29T01:32:28.000Z</published>
    <updated>2023-05-03T02:17:31.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java9"><a href="#Java9" class="headerlink" title="Java9"></a>Java9</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>模块化有两个目标:</p><ul><li>对JDK本身进行模块化</li><li>提供一个应用程序可以使用的模块系统</li></ul><p>它们是密切相关的,JDK的模块化可通过使用与应用程序开发人员使用的相同的模块系统来实现.通过引入模块化系统,使得Java真正的获得了对模块的三个核心原则的支持.<br>它带来的最重要的几个好处是:</p><span id="more"></span><ul><li>可靠的配置.模块系统在编译和运行之前会检查给定的模块组合是否满足所有依赖关系,从而导致更少的运行时错误(如因为多个版本的JAR都处于classpath中导致的<code>NoSuchMethodError</code>或<code>NoClassDefFoundError</code>错误).</li><li>强封装型.模块显示的声明了向外部公开的内容,未公开的内容是无法被外部访问的,这防止了来自其他模块的对其内部实现细节的依赖.</li><li>可扩展性.显式边界能够让开发团队并行工作,同时可创建可维护的代码库.</li><li>安全性.在JVM的最深层次上执行强封装,从而减少Java运行时的被攻击面,同时无法获得对敏感内部类的反射访问(Java是可以通过反射修改类的private成员的).</li></ul><p>JDK把代码划分成了很多个模块,每个模块都清晰的定义了暴露的内容以及依赖的模块.下面是Java9的模块关系图:</p><div align="center"><img width="900" height="462" src="https://zjjfly.github.io/images/20190529/j911-3.jpg"/></div>#### 定义模块模块拥有一个名称,并对相关的代码以及可能的其他资源拥进行分组,同时使用一个模块描述符进行描述.模块描述符保存在一个名为`module-info.java`的文件中.下面是`java.prefs`模块的`module-info.java`:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> java.prefs &#123;</span><br><span class="line">    <span class="keyword">requires</span> java.xml;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">exports</span> java.util.prefs;</span><br><span class="line"></span><br><span class="line">    uses java.util.prefs.PreferencesFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块描述的开头是关键字<code>module</code>,后面跟着一个模块的名称.由于模块都位于一个全局命名空间中,因此模块名称必须是唯一的.与包名称一样,可以使用反向DNS符号(例如com.mycompany.project.somemodule)等约定来确保模块的唯一性.<br>模块描述的主体是有三行,其中<code>requires</code>声明了对另一个模块的依赖.<code>exports</code>是一个导出声明,告知了别的模块它们可以访问这个包,没有export的包是无法被别的模块访问的.最后一行的意思是声明这个模块是服务<code>java.util.prefs.PreferencesFactory</code>的消费者.<br>下面列出了模块描述体中所有支持的语法:</p><ul><li><code>requires module.name</code>:表示本模块对一个模块的依赖,如果缺少这个模块则会无法编译和运行.</li><li><code>requires transitive module.name</code>:和<code>requires</code>基本一样,额外说明这个依赖是传递的,依赖本模块的其他模块会自动继承对这一依赖.当只需要其他模块供内部使用时,使用requires就足够了.但另一方面,如果需要在导出类型中使用另一个模块中的类型,那么就要使用<code>requires transitive</code>.</li><li><code>requires static module.name</code>:表示在编译的时候对这个模块是强依赖,但在运行时这个依赖是可选的.</li><li><code>exports pkg.name</code>:表示导出这个包,依赖这个模块的其他模块可以访问这个包.</li><li><code>exports pkg.name to module.name</code>:表示导出这个包给特定模块.可以使用逗号作为分隔符限定导出给多个模块.</li><li><code>opens pkg.name</code>:表示公开这个包,其他模块可以使用反射访问这个包中的类的私有成员.</li><li><code>opens pkg.name to module.name</code>:表示公开这个包给特定模块.同样可以指定对多个模块公开.</li><li><code>uses service.class.name</code>:它用于声明对一个服务接口的依赖.如果其他模块有通过<code>provides</code>声明实现这个服务接口,那么这个模块就可以通过<code>java.util.ServiceLoader</code>消费这些实现(如果实现就在同一个包中,也可以被消费).</li><li><code>provides service.class.name with service.class.impl.name</code>:表示为某个服务接口提供实现类.同样可以提供多个实现类.</li></ul><p>上面这些不同的语法提供了不同的可访问性.可见性包括两个方面:编译时可访问性和反射可访问性.下面是反映这些可访问性规则的表:</p><div align="center"><img width="795" height="277" src="https://zjjfly.github.io/images/20190529/j911-4.png"/></div>### JShellJShell是Java9加入的一个交互式的REPL(Read-Eval-Print Loop)工具,它可以对Java的声明,表达式进行求值,而且和一般的Java代码不一样,不需要它们处于一个方法中.而且它还有下面的几个便利的特性:<ul><li>tab键补全</li><li>自动补全声明尾部的分号</li><li>自动import需要的包</li><li>自动补全定义(为未绑定变量的表达式分配变量名)</li></ul><p>JShell的语法如下:</p><blockquote><p>jshell  &lt;options&gt; &lt;load files&gt;</p></blockquote><p>具体用法可以使用<code>jshell -h</code>查看.要退出JShell,可以输入<code>/ex</code>或<code>/exit</code>.除此之外,JShell中还可以输入其他一些命令,可以在JShell中输入<code>/?</code>或<code>/help</code>来查看.</p><p>JShell的主要作用是执行一些简短的实验性质的代码,或者作为Java脚本(一般以<code>.jsh</code>结尾)的执行器.</p><h3 id="Process-API"><a href="#Process-API" class="headerlink" title="Process API"></a>Process API</h3><p>Java9中加入了两个新的进程相关的接口:<code>ProcessHandle</code>和<code>ProcessHandle.Info</code>.一个<code>ProcessHandle</code>标识了一个操作系统进程并提供了管理进程的方法.<code>Info</code>存储了进程相关的信息.这两个接口的引入解决了下面几个问题.</p><h4 id="判断进程是否存活"><a href="#判断进程是否存活" class="headerlink" title="判断进程是否存活"></a>判断进程是否存活</h4><p>在之前版本的Java中,只有通过进程的PID去标识一个进程,这种方法的问题是:PID是可以重用的.<br>对于桌面和服务器操作系统,它们会尽量的不重用PID,但对于一些嵌入式系统,PID是一个16位的数字,所以很容易发生重用.但有了<code>ProcessHandle</code>,使用它的<code>isAlive()</code>方法就可以避免这个问题.</p><h4 id="获取进程PID"><a href="#获取进程PID" class="headerlink" title="获取进程PID"></a>获取进程PID</h4><p>获取进程的PID在实际编程中是很有用的,在之前,Java的<code>Process</code>类没有任何方法可以获取PID.而现在,可以调用<code>toHandle()</code>方法把<code>Process</code>对象转换成<code>ProcessHandle</code>对象,然后调用<code>pid()</code>方法就可以得到进程PID.<br>如果需要得到当前进程的PID,可以调用<code>ProcessHandle.current().pid()</code>.</p><h4 id="获取进程信息"><a href="#获取进程信息" class="headerlink" title="获取进程信息"></a>获取进程信息</h4><p><code>ProcessHandle</code>对象调用<code>info()</code>方法可以得到一个<code>ProcessHandle.Info</code>对象,通过它可以获取下面的信息:</p><ul><li><code>command()</code>方法返回<code>Optional&lt;String&gt;</code>,包含了启动进程的命令.</li><li><code>arguments()</code>方法返回<code>Optional&lt;String[]&gt;</code>,包含启动进程的命令的参数.</li><li><code>commandLine()</code>返回<code>Optional&lt;String&gt;</code>,包含了启动进程的命令和参数.</li><li><code>startInstant()</code>返回<code>Optional&lt;Instant&gt;</code>,包含了进程的起始时间.</li><li><code>totalCpuDuration()</code>返回<code>Optional&lt;Duration&gt;</code>,包含了进程从开始起占用的CPU时间.</li><li><code>user()</code>返回<code>Optional&lt;String&gt;</code>,包含了进程的所有者的名字.<br>为什么返回的类型都是<code>Optional</code>?因为无法保证操作系统或Java的实现可以返回这些信息.但对于大多数操作系统来说,这些信息都是可以获得的.</li></ul><h4 id="列出进程"><a href="#列出进程" class="headerlink" title="列出进程"></a>列出进程</h4><p><code>ProcessHandle</code>提供了方法用于列出进程,包括:</p><ul><li>列出进程的所有子进程,使用<code>children()</code>实例方法.</li><li>列出进程的所有后代进程,使用<code>descendants()</code>实例方法.</li><li>列出系统的所有进程,使用<code>allProcesses()</code>静态方法.</li></ul><p>这些方法返回的都是<code>Stream&lt;ProcessHandle&gt;</code>.要注意,这些方法只返回在调用的时候存活的进程,但不保证在遍历返回结果的时候这些进程仍然存活.</p><h4 id="等待进程结束"><a href="#等待进程结束" class="headerlink" title="等待进程结束"></a>等待进程结束</h4><p>之前Java等待进程结束,需要使用使用循环来定期调用<code>isAlive()</code>方法.<code>ProcessHandle</code>提供了<code>onExit()</code>方法来更优雅的完成这一任务.它返回的类型是<code>CompletableFuture&lt;ProcessHandle&gt;</code>(<code>CompletableFuture</code>是Java8加入的异步API),你可以通过<code>handle.onExit().join()</code>来等待进程结束.你可以多次调用<code>onExit()</code>,每次返回的都是不同的<code>CompletableFuture</code>对象,它们都和相同的进程关联.</p><h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><p><code>ProcessHandle</code>提供了<code>destroy()</code>和<code>destroyForcibly()</code>方法来终止进程.前者是尽量平稳的结束进程,而后者是强行终止进程.但进程的终止依赖很多因素,所以调用这两个方法返回<code>true</code>的话,不意味着进程已经终止了,只表示操作系统接受了你的终止请求,具体什么时候终止是无法确定的.</p><h3 id="便利的集合工厂方法"><a href="#便利的集合工厂方法" class="headerlink" title="便利的集合工厂方法"></a>便利的集合工厂方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(list.getClass());</span><br><span class="line">Map&lt;Integer, String&gt; map = Map.of(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>, <span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">System.out.println(map.getClass());</span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(set.getClass());</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>class java.util.ImmutableCollections.ListN<br/><br>class java.util.ImmutableCollections.MapN<br/><br>class java.util.ImmutableCollections.SetN</p></blockquote><p>可以看出,这些生成的对象的类型都是不可变集合,所以我们<strong>不能对其中的元素进行修改或者排序</strong>.<br>还加入了<code>copyOf</code>方法用于拷贝集合,它在<code>List</code>,<code>Set</code>,<code>Map</code>都有.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; copy = List.copyOf(strings);</span><br><span class="line">System.out.println(copy);</span><br><span class="line">System.out.println(copy.getClass());</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>[1, 2]<br/><br>class java.util.ImmutableCollections$List12</p></blockquote><p>可以看出,得到的拷贝也是不可变集合.</p><h3 id="Stream-API增强"><a href="#Stream-API增强" class="headerlink" title="Stream API增强"></a>Stream API增强</h3><p>加入了三个新的方法:<code>ofNullable</code>,<code>takeWhile</code>,<code>dropWhile</code>,<code>iterate</code>.</p><h4 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a>ofNullable</h4><p>它是对<code>of</code>的增强,在<code>of</code>中传入<code>null</code>会抛<code>NullPointerException</code>,这个新方法不会,而只会返回一个空的<code>Stream</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> Stream.ofNullable(<span class="literal">null</span>).count();</span><br></pre></td></tr></table></figure><blockquote><p>0</p></blockquote><h4 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h4><p>它可以传入一个<code>Predicate</code>,它会获取最长的符合这个<code>Predicate</code>的头<code>Stream</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lessThan4 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).takeWhile(i -&gt; i &lt;= <span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><p>[1,2,3]</p></blockquote><h4 id="dropWhile"><a href="#dropWhile" class="headerlink" title="dropWhile"></a>dropWhile</h4><p>它可以传入一个<code>Predicate</code>,它会获取最长的不符合这个<code>Predicate</code>的尾<code>Stream</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; largerThan3 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).dropWhile(i -&gt; i &lt; <span class="number">4</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><p>[4,5]</p></blockquote><h4 id="iterate"><a href="#iterate" class="headerlink" title="iterate"></a>iterate</h4><p>其实之前已经有了存在一个<code>iterate</code>方法,这次是加入了一个重载方法,可以传入一个<code>Predicate</code>作为结束条件,一旦生成的元素不符合这个<code>Predicate</code>,那么这个Stream就会结束.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lessThan100 = Stream.iterate(<span class="number">1</span>, i -&gt; i &lt; <span class="number">100</span>, i -&gt; i + <span class="number">1</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><p>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10,<br>11, 12, 13, 14, 15, 16, 17, 18, 19, 20,<br>21, 22, 23, 24, 25, 26, 27, 28, 29, 30,<br>31, 32, 33, 34, 35, 36, 37, 38, 39, 40,<br>41, 42, 43, 44, 45, 46, 47, 48, 49, 50,<br>51, 52, 53, 54, 55, 56, 57, 58, 59, 60,<br>61, 62, 63, 64, 65, 66, 67, 68, 69, 70,<br>71, 72, 73, 74, 75, 76, 77, 78, 79, 80,<br>81, 82, 83, 84, 85, 86, 87, 88, 89, 90,<br>91, 92, 93, 94, 95, 96, 97, 98, 99]</p></blockquote><h3 id="InputStream增强"><a href="#InputStream增强" class="headerlink" title="InputStream增强"></a>InputStream增强</h3><p>为<code>InputStream</code>加入了一个<code>transferTo</code>,用于把输入流传递给输出流.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;build.gradle&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">build</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;build.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(build)) &#123;</span><br><span class="line">    fileInputStream.transferTo(outputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对Project-Coin的改进"><a href="#对Project-Coin的改进" class="headerlink" title="对Project Coin的改进"></a>对Project Coin的改进</h3><p>Project Coin是Java7的时候的引入的,它包括下面几个特性:</p><ul><li><code>swtich</code>支持String类型</li><li>二进制整形字面量</li><li>数字字面量支持下划线</li><li><code>catch</code>可以一次捕获多种异常</li><li>简化泛型类的实例化</li><li><code>try-with-resource</code>表达式</li><li>改进对不定参数方法的调用</li></ul><p>Java9中,对其进行了五个方面的改进:</p><ul><li><code>@SafeVarargs</code>可以加在private方法上</li><li>try-with-resource中不再必须声明新的对象,可以传入已经声明的的<code>final</code>或等价于<code>final</code>的对象</li><li>不再支持使用下划线<code>_</code>作为变量名</li><li>接口支持有具体实现的私有方法</li></ul><h3 id="Variable-handlers"><a href="#Variable-handlers" class="headerlink" title="Variable handlers"></a>Variable handlers</h3><p>随着Java中的并发和并行编程的不断扩大,我们经常会需要对某个类的字段进行原子或有序操作,但是JVM对Java开发者所开放的权限非常有限.例如:如果要原子性地增加某个字段的值,到目前为止我们可以使用下面三种方式:</p><ul><li>使用<code>AtomicInteger</code>来达到这种效果,这种间接管理方式增加了空间开销,还会导致额外的并发问题</li><li>使用原子性的<code>FieldUpdaters</code>,由于利用了反射机制,操作开销也会更大</li><li>使用<code>sun.misc.Unsafe</code>提供的JVM内置函数API,虽然这种方式比较快,但它会损害安全性和可移植性,当然在实际开发中也很少会这么做.</li></ul><p><code>VarHandle</code>的出现替代了<code>java.util.concurrent.atomic</code>和<code>sun.misc.Unsafe</code>的部分操作.并且提供了一系列标准的内存屏障操作,用于更加细粒度的控制内存排序,在安全性,可用性和性能上都要优于现有的API.<br>这些操作主要是：</p><ul><li>访问&#x2F;修改对象成员</li><li>访问&#x2F;修改数组元素</li></ul><h3 id="去除过期的类或字段的import声明的编译警告"><a href="#去除过期的类或字段的import声明的编译警告" class="headerlink" title="去除过期的类或字段的import声明的编译警告"></a>去除过期的类或字段的<code>import</code>声明的编译警告</h3><p>以前,如果代码中导入了被<code>@Deprecated</code>标注的类或方法,编译的时候会有警告.现在,编译器在下列的情况下不会产生过时告警:</p><ul><li>使用<code>@Deprecated</code>标注类或方法</li><li>使用<code>@SuppressWarnings</code>标注类或方法</li><li>产生告警的代码和声明在父类中</li><li>只用<code>import</code>导入过时的类,但没有在其他任何地方使用</li></ul><h3 id="JDK9的其他一些改进"><a href="#JDK9的其他一些改进" class="headerlink" title="JDK9的其他一些改进"></a>JDK9的其他一些改进</h3><h4 id="Compact-strings"><a href="#Compact-strings" class="headerlink" title="Compact strings"></a>Compact strings</h4><p>紧凑字符串.之前的字符串的底层使用的是<code>char[]</code>存储.一个char要占16bits,但实际开发过程占,使用最多的是<code>Latin-1</code>字符,它们只需占用8bits或者说1byte.现在内部使用<code>byte[]</code>来存储,节约了内存空间.</p><h4 id="改进的竞争锁"><a href="#改进的竞争锁" class="headerlink" title="改进的竞争锁"></a>改进的竞争锁</h4><p>Java对多个线程共享的数据的管理做的不错,它为每个对象和类分配一个monitor,这些monitor的锁在任何时候只会被一个线程控制.从本质上说,这些锁就是给予了线程这些对象的monitor.如果有其他线程在等待这个锁的队列中,那么就叫竞争锁.<br>这是为了提高JVM管理竞争锁的整体性能,它的提升主要体现在下面三个操作:</p><ul><li>Faster monitor enter</li><li>Faster monitor exit</li><li>Faster notifications</li></ul><h4 id="分段的代码缓存"><a href="#分段的代码缓存" class="headerlink" title="分段的代码缓存"></a>分段的代码缓存</h4><p>这个改进使得JVM有更快的更高效的运行时.它的核心是把代码缓存分成三块,每一块存储特定类型的编译好的代码,</p><div align="center"><img width="796" height="455" src="https://zjjfly.github.io/images/20190529/j911-1.JPG"/></div>代码缓存区是一个固定大小的区域.默认情况下,其中有3MB是固定存放non-methed代码的,剩余的部分平均分配给profiled和non-profiled代码.用户可以通过JVM参数手动调节.> -xx:NonMethodCodeHeapSize> -xx:ProfiledCodeHeapSize> -xx:NonProfiledCodeHeapSize<h4 id="优化字符串拼接"><a href="#优化字符串拼接" class="headerlink" title="优化字符串拼接"></a>优化字符串拼接</h4><p>之前,<code>javac</code>会把<code>&quot;hello,&quot;+&quot;world&quot;</code>这样的代码在编译的时候转换成调用<code>StringBuiler::append</code>方法.现在,<code>javac</code>生成的字节码变成了使用<code>invokedynamic</code>指令,以后对字符串拼接的优化不再需要改动编译器生成的字节码,因为不再和具体的实现绑定了.</p><h4 id="更智能的javac-第二阶段"><a href="#更智能的javac-第二阶段" class="headerlink" title="更智能的javac,第二阶段"></a>更智能的<code>javac</code>,第二阶段</h4><p><code>sjavac</code>,一个更智能的<code>javac</code>,支持增量编译,加快了编译速度,但目前还没有替代<code>javac</code>.这次在第一阶段的基础上增强了它的稳定性和可移植性.</p><h4 id="处理Lint和Doclint的告警"><a href="#处理Lint和Doclint的告警" class="headerlink" title="处理Lint和Doclint的告警"></a>处理Lint和Doclint的告警</h4><p>之前的JDK编译的时候会由<code>javac</code>发出很多lint(字节码和源码检查)和doclint(javadoc检查)告警,这个提案就是为了处理这些告警,至少是核心库的告警.</p><h4 id="javac中使用分层归因"><a href="#javac中使用分层归因" class="headerlink" title="javac中使用分层归因"></a><code>javac</code>中使用分层归因</h4><p><code>javac</code>会在编译的时候进行类型推断,之前使用的是一种推断归因工具,这种工具的类型推断结果虽然准确但性能不高,现在使用一种新的叫做分层归因工具替代它,目的是为了加快编译速度.</p><h4 id="Annotations-pipeline-2-0"><a href="#Annotations-pipeline-2-0" class="headerlink" title="Annotations pipeline 2.0"></a>Annotations pipeline 2.0</h4><p>在Java8中,引入了三个特性：</p><ul><li>lambda表达式</li><li>重复注解</li><li>类型注解</li></ul><p>这三个特性影响了Java注解,但<code>javac</code>没有对原有的对注解的处理做修改,而是加入了一些硬编码对这些新的注解进行处理,但这种方式效率不高而且维护麻烦,所以这个改进是为了去掉这些硬编码,重构了处理注解的代码.</p><h4 id="关键区域的预留栈空间"><a href="#关键区域的预留栈空间" class="headerlink" title="关键区域的预留栈空间"></a>关键区域的预留栈空间</h4><p>为关键代码区域加上保留的线程栈空间,以此来减少发生<code>StackOverflowError</code>,的可能性.如果当前执行的方法的栈空间不够了,但这个方法有注解<code>jdk.internal.vm.annotation.ReservedStackAccess</code>,那么就会分配一段临时的栈空间让方法继续执行.当然,如果需要的额外空间很大,最终还是会抛出<code>StackOverflowError</code>.</p><h4 id="把G1垃圾收集器作为默认的垃圾收集器"><a href="#把G1垃圾收集器作为默认的垃圾收集器" class="headerlink" title="把G1垃圾收集器作为默认的垃圾收集器"></a>把G1垃圾收集器作为默认的垃圾收集器</h4><p>之前默认的收集器是Parallel GC,它的优点是高吞吐量.但总体上来说,较少的暂停时间是比高吞吐量更重要的,G1在前者是有着很好的表现的,而且G1经历了8和9已经非常成熟,所以使用它作为默认垃圾收集器.</p><h2 id="Java10"><a href="#Java10" class="headerlink" title="Java10"></a>Java10</h2><h3 id="类型推断增强"><a href="#类型推断增强" class="headerlink" title="类型推断增强"></a>类型推断增强</h3><p>Java10的类型推断功能进行了强化.类型推断指的是编译器根据解析到的存在于代码中的信息,如字面量,操作,方法调用或声明,通过一些规则,推断出变量的类型.</p><h4 id="本地变量的类型推断"><a href="#本地变量的类型推断" class="headerlink" title="本地变量的类型推断"></a>本地变量的类型推断</h4><p>这次的提升使得局部变量的声明更加简单,不再需要显示的写明类型,而仅仅使用标识符<code>var</code>,编译器就可以自动推断出它的类型.但这种用法也有一些限制:</p><ul><li>不能在没有初始化的声明中使用</li><li>不能在同时声明多个变量的时候使用</li><li>不能用于数组字面量</li><li>不能用于元表达式,如lambda和方法引用</li><li>不能再<code>catch</code>中使用</li></ul><p><code>var</code>可以在for循环中使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">numbers</span> <span class="operator">=</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> nr : numbers) &#123;</span><br><span class="line">    System.out.print(nr + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="var和原始类型"><a href="#var和原始类型" class="headerlink" title="var和原始类型"></a>var和原始类型</h4><p><code>var</code>用于原始类型应该是最常见,但其中也有一些使人迷惑的地方.实际上关于原始类型的一些类型推断的规则并没有被修改,如:</p><ul><li>整数字面量的类型是<code>int</code>.</li><li>浮点数字面量的类型是<code>double</code>.</li><li>算术运算中,如果其中一个操作数是<code>char</code>, <code>byte</code>, <code>short</code>,or <code>int</code>,那么结果至少会提升为<code>int</code>;如果其中一个操作数是<code>long</code>, <code>float</code>或 <code>double</code>，那么结果至少会提升为<code>long</code>, <code>float</code>或 <code>double</code>.</li></ul><p>所以如果你期待能把<code>var n= 5/2</code>中的<code>n</code>推断为<code>float</code>或<code>double</code>，那你可能要失望了.</p><h4 id="派生类型的类型推断"><a href="#派生类型的类型推断" class="headerlink" title="派生类型的类型推断"></a>派生类型的类型推断</h4><p>在之前的Java中,一种常用的模式是把一个具体类型的对象赋值给一个声明为它的基类的变量.但如果你使用<code>var</code>声明这个变量,那么类型推断的结果为具体的类型.这和你的期望可能不符,需要注意.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whistle</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Parent-Whistle&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whistle</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Child-Whistle&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stand</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Child-stand&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();                             </span><br><span class="line">        obj.whistle(); </span><br><span class="line">        obj.stand();     <span class="comment">// type of obj inferred as Child </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有一个既可能返回<code>Parent</code>类型的对象,也可能返回<code>Child</code>对象的方法,它的返回值类型会被推断为什么?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Parent <span class="title function_">getObject</span><span class="params">(String type)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;Parent&quot;</span>)) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Parent</span>(); </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Child</span>(); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> getObject(<span class="string">&quot;Child&quot;</span>); </span><br><span class="line">        obj.whistle(); </span><br><span class="line">        obj.stand(); <span class="comment">// This line doesn&#x27;t compile </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>所以推断的结果是<code>Parent</code>类型.这和以前的推断规则是一样的.</p><p>如果一个变量使用<code>var</code>声明,这个对象的类型是在编译期确定的.如果一个方法的返回值被赋值给一个<code>var</code>声明的变量,那么编译器就把方法的返回类型推断为这个变量的类型.</p><h4 id="接口的类型推断"><a href="#接口的类型推断" class="headerlink" title="接口的类型推断"></a>接口的类型推断</h4><p>接口的推断规则和派生类是一样的.把接口实现类型的对象赋值给<code>var</code>声明的变量,那么类型推断的结果是实现类型.如果有一个返回值的实际类型不确定的方法,把它的返回值赋值给<code>var</code>声明的变量,类型推断的结果就是这个方法声明的返回类型.</p><h4 id="var和数组"><a href="#var和数组" class="headerlink" title="var和数组"></a>var和数组</h4><p>使用<code>var</code>不意味着简单的把变量的类型声明换成<code>var</code>.数组就是一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[] = &#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>你不能使用下面的代码来声明这个数组:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>[] name = &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> name[] = &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> name=&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>正确的做法是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="泛型的类型推断"><a href="#泛型的类型推断" class="headerlink" title="泛型的类型推断"></a>泛型的类型推断</h4><p>带泛型的类型使用var,需要小心.比如下面这样的写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">names</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">names.add(<span class="number">1</span>); </span><br><span class="line">names.add(<span class="string">&quot;Mala&quot;</span>); </span><br><span class="line">names.add(<span class="number">10.9</span>); </span><br><span class="line">names.add(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这显示出编译器无法确定变量<code>names</code>的类型参数是什么,所以可以放入任意类型的元素.这显然违背了声明这个变量的初衷.<br>正确的写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><h3 id="JDK10的其他一些改进"><a href="#JDK10的其他一些改进" class="headerlink" title="JDK10的其他一些改进"></a>JDK10的其他一些改进</h3><h4 id="Thread-local-handshake"><a href="#Thread-local-handshake" class="headerlink" title="Thread-local handshake"></a>Thread-local handshake</h4><p>Java10加入的对多线程的改进,使得JVM可以不需要进行全局的暂停就可以停止单个线程,这可以提高偏向锁撤销的速度,降低总体VM延迟,提供更安全的stack trace,减少内存屏障的使用.要启用这个特性,需要JVM参数:</p><blockquote><p>XX:ThreadLocalHandshakes</p></blockquote><p>####s 新的版本格式<br>新的版本命名格式,原来是使用<code>8u211</code>这样的格式,现在使用的是形如<code>12.0.1</code>的格式.</p><h4 id="合并JDK代码"><a href="#合并JDK代码" class="headerlink" title="合并JDK代码"></a>合并JDK代码</h4><p>Java9由8个不同的代码库组成,如下图:</p><div align="center"><img width="900" height="570" src="https://zjjfly.github.io/images/20190529/j911-2.png"/></div>到了Java10,这几个仓库合成了一个,这样使得开发,维护和更新更简单.<h4 id="支持在其他内存设备上分配堆空间"><a href="#支持在其他内存设备上分配堆空间" class="headerlink" title="支持在其他内存设备上分配堆空间"></a>支持在其他内存设备上分配堆空间</h4><p>Java10对非DRAM的内存设备提供了支持,要启用需要JVM参数:</p><blockquote><p>XX:AllocateHeapAt&#x3D;file-system path</p></blockquote><h4 id="Unicode-8-0-0"><a href="#Unicode-8-0-0" class="headerlink" title="Unicode 8.0.0"></a>Unicode 8.0.0</h4><p>支持Unicode8.0.0标准</p><h4 id="根证书"><a href="#根证书" class="headerlink" title="根证书"></a>根证书</h4><p>在JDK中加入默认的根证书</p><h4 id="实验性质的基于Java的JIT编译器"><a href="#实验性质的基于Java的JIT编译器" class="headerlink" title="实验性质的基于Java的JIT编译器"></a>实验性质的基于Java的JIT编译器</h4><p>即Graal,它也是GraalVM的默认JIT编译器.它使用JVM的编译器接口(JDK9中加入的).它不是为了和现有的JIT竞争,而是为了探索用于HotSpot的Java-on-Java技术.</p><h2 id="JDK11"><a href="#JDK11" class="headerlink" title="JDK11"></a>JDK11</h2><h3 id="lambda的参数支持var语法"><a href="#lambda的参数支持var语法" class="headerlink" title="lambda的参数支持var语法"></a>lambda的参数支持<code>var</code>语法</h3><p><code>var</code>现在可以在lambda表达式中使用,但要使用的话必须加在所有的形参上:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparatorsort((<span class="keyword">var</span> s1, <span class="keyword">var</span> s2) -&gt; s1.length() - s2.length());</span><br></pre></td></tr></table></figure><p>如果lambda只有一个参数,你想使用<code>var</code>,那你不能省略<code>()</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x -&gt; x &gt; <span class="number">10</span>; <span class="comment">// Won&#x27;t compile</span></span><br></pre></td></tr></table></figure><p>现在lambda表达式的参数可以加上注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">numbers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;bc&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        add(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Comparator&lt;String&gt; comparator = (<span class="meta">@NotNull</span> <span class="keyword">var</span> s1, <span class="meta">@NotNull</span> <span class="keyword">var</span> s2) -&gt; s1.length() - s2.length();</span><br></pre></td></tr></table></figure><h3 id="Epsilon-GC"><a href="#Epsilon-GC" class="headerlink" title="Epsilon GC"></a>Epsilon GC</h3><p>Epsilon GC是一个no-operation (no-op) GC,它不会做任何垃圾收集工作,它只处理内存分配,当堆内存空间耗尽了,JVM就会停止工作.<br>为什么要加入这样一个很奇怪的GC?实际上,它是用来预测你的程序的性能的.因为影响Java程序性能的除了GC,还有可能是系统本身的问题或编译器的问题,所以你可以把一个程序用Epsilon GC运行,然后使用另一些GC运行,通过对比,你就可以排除了系统或编译器的因素,只需要从内存占用,吞吐量,延迟这些方面考量,找到最适合这个程序的GC.<br>开启Epsilon GC的方法是在运行程序的时候加如下的参数:</p><blockquote><p>-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC</p></blockquote><h3 id="新的HTTP客户端"><a href="#新的HTTP客户端" class="headerlink" title="新的HTTP客户端"></a>新的HTTP客户端</h3><p>在Java1.1的时候首次加入了Http客户端,对应的类是<code>HttpURLConnection</code>,但它存在很多问题,所以开发者们并不喜欢,而是使用其他的第三方的API.<br>新的HTTP客户端支持HTTP2.0,支持异步非阻塞的请求,并提供了更易于使用的API.实际上从9开始把这个新的客户端加入了孵化器,经过10的一系列修改,在11中最终发布.<br>例子:</p><h4 id="构建request"><a href="#构建request" class="headerlink" title="构建request"></a>构建request</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.<span class="type">Builder</span> <span class="variable">requestBuilder</span> <span class="operator">=</span> HttpRequest.newBuilder();</span><br><span class="line"><span class="type">HttpRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> requestBuilder</span><br><span class="line">    .uri(<span class="keyword">new</span> <span class="title class_">URI</span>(<span class="string">&quot;https://postman-echo.com/post&quot;</span>))</span><br><span class="line">    <span class="comment">//设定HTTP协议版本</span></span><br><span class="line">    .version(Version.HTTP_2)</span><br><span class="line">    <span class="comment">//设定Header</span></span><br><span class="line">    .header(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    .timeout(Duration.of(<span class="number">10</span>, SECONDS))</span><br><span class="line">    <span class="comment">//设定HTTP Method</span></span><br><span class="line">    .POST(HttpRequest.BodyPublishers.ofString(<span class="string">&quot;Sample request body&quot;</span>))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h4 id="构建client"><a href="#构建client" class="headerlink" title="构建client"></a>构建client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HttpClient.<span class="type">Builder</span> <span class="variable">clientBuilder</span> <span class="operator">=</span> HttpClient.newBuilder();</span><br><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> clientBuilder</span><br><span class="line">    <span class="comment">//设置重定向规则</span></span><br><span class="line">    .followRedirects(HttpClient.Redirect.ALWAYS)</span><br><span class="line">    <span class="comment">//设置代理</span></span><br><span class="line">    .proxy(ProxySelector.getDefault())</span><br><span class="line">    .authenticator(<span class="keyword">new</span> <span class="title class_">Authenticator</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> PasswordAuthentication <span class="title function_">getPasswordAuthentication</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PasswordAuthentication</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>.toCharArray());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h4 id="发送同步请求请求"><a href="#发送同步请求请求" class="headerlink" title="发送同步请求请求"></a>发送同步请求请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = client.send(httpRequest, HttpResponse.BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><h4 id="发送异步请求"><a href="#发送异步请求" class="headerlink" title="发送异步请求"></a>发送异步请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; responseFuture = client</span><br><span class="line">        .sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString());</span><br><span class="line"><span class="comment">//设置回调函数</span></span><br><span class="line">responseFuture.whenCompleteAsync((stringHttpResponse, throwable) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span>!=throwable)&#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(stringHttpResponse.body());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//等待future完成</span></span><br><span class="line">responseFuture.join();</span><br></pre></td></tr></table></figure><p>可以在<a href="https://golb.hplar.ch/2019/01/java-11-http-client.html">这里</a>进一步了解.</p><h3 id="字符串增强"><a href="#字符串增强" class="headerlink" title="字符串增强"></a>字符串增强</h3><p><code>String</code>加入了一些便利的方法:<code>isBlank</code>,<code>strip</code>,<code>stripTrailing</code>,<code>stripLeading</code>,<code>repeat</code>,<code>lines</code>.</p><h4 id="isBlank"><a href="#isBlank" class="headerlink" title="isBlank"></a>isBlank</h4><p>判断字符串是否为空或全是空格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; &quot;</span>.isBlank();</span><br></pre></td></tr></table></figure><blockquote><p>true</p></blockquote><h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h4><p>这个方法和<code>trim</code>的作用是一样的,去掉字符串首尾的空格.区别是它们对空格的定义不同:<code>trim</code>认为任何小于等于<code>U+0020</code>(这是字符的unicode码)的字符是空格,而<code>strip</code>认为<code>Character.isWhitespace(int)</code>返回<code>true</code>的字符就是空格.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;\u2000&#x27;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> c + <span class="string">&quot;abc&quot;</span> + c;</span><br><span class="line">System.out.println(s.strip());</span><br><span class="line">System.out.println(s.trim());</span><br></pre></td></tr></table></figure><blockquote><p>abc<br>&amp;ensp;abc </p></blockquote><h4 id="stripTrailing"><a href="#stripTrailing" class="headerlink" title="stripTrailing"></a>stripTrailing</h4><p>把字符串尾部的空格去掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; java &quot;</span>.stripTrailing()</span><br></pre></td></tr></table></figure><blockquote><p>&amp;ensp;java</p></blockquote><h4 id="stripLeading"><a href="#stripLeading" class="headerlink" title="stripLeading"></a>stripLeading</h4><p>把字符串的头部的空格去掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; java &quot;</span>.stripLeading()</span><br></pre></td></tr></table></figure><blockquote><p>java</p></blockquote><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p>重复字符串特定的次数并返回.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;java&quot;</span>.repeat(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><blockquote><p>javajavajava</p></blockquote><h4 id="lines"><a href="#lines" class="headerlink" title="lines"></a>lines</h4><p>把字符串以换行符话划分并返回一个<code>Stream&lt;String&gt;</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().count()</span><br></pre></td></tr></table></figure><blockquote><p>3</p></blockquote><h3 id="Optional增强"><a href="#Optional增强" class="headerlink" title="Optional增强"></a>Optional增强</h3><p>从9到11,每个版本都为<code>Optional</code>类加入了一个或几个新方法,包括:<code>isEmpty</code>,<code>ifPresentOrElse</code>,<code>or</code>,<code>stream</code>,<code>orElseThrow</code>.</p><h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> Optional.of(<span class="string">&quot;1&quot;</span>).isEmpty();</span><br></pre></td></tr></table></figure><blockquote><p>false</p></blockquote><h4 id="ifPresentOrElse"><a href="#ifPresentOrElse" class="headerlink" title="ifPresentOrElse"></a>ifPresentOrElse</h4><p>它传入一个<code>Consumer</code>函数和一个<code>Runnable</code>函数.当<code>Optional</code>不为空,那么执行<code>Consumer</code>函数;如果是空的,那么运行<code>Runnable</code>函数.这个方法避免了之前那种不得不使用if-else来执行Optional非空和空这两种情况的分支.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional.&lt;String&gt;empty().ifPresentOrElse(System.out::println,() -&gt; </span><br><span class="line">    System.out.println(<span class="string">&quot;no string&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>no string</p></blockquote><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p>它传入一个会返回<code>Optional</code>的<code>Supplier</code>.当<code>Optional</code>不为空,那么直接返回调用这个方法的对象;如果是空的,那么返回<code>Supplier</code>函数的结果.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; or = Optional.&lt;String&gt;empty().or(() -&gt; Optional.of(<span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>Optional[1]</p></blockquote><h4 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h4><p>它可以把<code>Optional</code>转换成<code>Stream</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Optional.of(<span class="number">1</span>).stream().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><p>[1]</p></blockquote><h4 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a>orElseThrow</h4><p>如果<code>Optional</code>不为空,那么直接返回其中的值;如果为空,那么直接抛出异常<code>NoSuchElementException</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Optional.&lt;String&gt;empty().orElseThrow();</span><br></pre></td></tr></table></figure><blockquote><p>Exception in thread “main” java.util.NoSuchElementException: No value present<br>&amp;emsp;&amp;emsp;at java.base&#x2F;java.util.Optional.orElseThrow(Optional.java:382)</p></blockquote><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>ZGC(Z Garbage Collector),一个全新的可扩展,低延迟的GC.它可以处理从KB到TB级别的堆内存.作为一个并发的垃圾收集器,它承诺它造成的系统延迟不会超过10毫秒,即便是对于很大的堆内存.<br>它最大的一个特点是:它是一个并发的收集器,包括对内存的标记,复制,移动都是并发的.它还有一个并发的引用处理器,用于处理各种类型的引用(soft reference,weak reference,phantom reference).<br>它和其他的HotSpot虚拟机的GC不同的是,它使用了两种新技术:着色指针和读屏障.具体的实现细节可以看<a href="https://mp.weixin.qq.com/s/KUCs_BJUNfMMCO1T3_WAjw">这篇文章</a>.<br>开启ZGC的方法,在运行的时候加入下面的参数:</p><blockquote><p>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</p></blockquote><p>它目前还处于实验阶段,还有一些不足之处(如没有分代),需谨慎使用.它目前<strong>只支持Linux 64位系统</strong>.</p><h3 id="JDK11的其他一些改进"><a href="#JDK11的其他一些改进" class="headerlink" title="JDK11的其他一些改进"></a>JDK11的其他一些改进</h3><h4 id="新增读取文件内容的方法"><a href="#新增读取文件内容的方法" class="headerlink" title="新增读取文件内容的方法"></a>新增读取文件内容的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> Files.readString(Path.of(<span class="string">&quot;pom.xml&quot;</span>));</span><br><span class="line"><span class="comment">//do something</span></span><br></pre></td></tr></table></figure><h4 id="基于嵌套的访问控制"><a href="#基于嵌套的访问控制" class="headerlink" title="基于嵌套的访问控制"></a>基于嵌套的访问控制</h4><p>以前的Java嵌套类对于宿主类的私有字段的访问是通过放宽这个私有字段的访问控制或加入桥接方法来实现的.<br>例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">outerInt</span> <span class="operator">=</span> <span class="number">20</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">innerInt</span> <span class="operator">=</span> outerInt;     <span class="comment">// Can Inner access outerInt? </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的反编译结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decompiled class Outer </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123; </span><br><span class="line">        <span class="type">int</span> innerInt; </span><br><span class="line">        <span class="keyword">final</span> Outer <span class="built_in">this</span>$<span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">()</span> &#123; </span><br><span class="line">            <span class="built_in">this</span>$<span class="number">0</span> = Outer.<span class="built_in">this</span>; </span><br><span class="line">            <span class="built_in">super</span>(); </span><br><span class="line">            innerInt = outerInt; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">()</span> &#123; </span><br><span class="line">        outerInt = <span class="number">20</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> outerInt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个改进使得内部类不再需要放宽这个私有字段的访问控制或加入桥接方法,就可以访问外部类的私有成员,这个改动直接体现在编译后的字节码中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">outerInt</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">innerInt</span> <span class="operator">=</span> Outer.<span class="built_in">this</span>.outerInt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态类文件常量"><a href="#动态类文件常量" class="headerlink" title="动态类文件常量"></a>动态类文件常量</h4><p>这个改动扩展了类文件格式,加入了<code>CONSTANT_Dynamic</code>这个新的常量类型.这个常量池用于存储和<code>invokedynamic</code>指令相关的常量.</p><h4 id="针对AArch64处理器改进一些方法的实现"><a href="#针对AArch64处理器改进一些方法的实现" class="headerlink" title="针对AArch64处理器改进一些方法的实现"></a>针对AArch64处理器改进一些方法的实现</h4><p>对于AArch64处理器改进现有的string,array相关函数,并新实现java.lang.Math的sin,cos,log方法.</p><h4 id="删除Java-EE及CORBA模块"><a href="#删除Java-EE及CORBA模块" class="headerlink" title="删除Java EE及CORBA模块"></a>删除Java EE及CORBA模块</h4><p>将java9标记废弃的Java EE及CORBA模块移除掉,具体如下:</p><ul><li>xml相关的java.xml.ws,java.xml.bind,java.xml.ws,java.xml.ws.annotation,jdk.xml.bind,jdk.xml.ws被移除,只剩下java.xml,java.xml.crypto,jdk.xml.dom这几个模块</li><li>java.corba,java.se.ee,java.activation,java.transaction被移除，但是新增一个java.transaction.xa模块</li></ul><h4 id="支持Unicode10"><a href="#支持Unicode10" class="headerlink" title="支持Unicode10"></a>支持Unicode10</h4><p>升级现有的API，支持Unicode10.0.0</p><h4 id="支持TLS1-3"><a href="#支持TLS1-3" class="headerlink" title="支持TLS1.3"></a>支持TLS1.3</h4><p>支持RFC 8446中的TLS 1.3版本</p><h4 id="废弃JS引擎Nashorn"><a href="#废弃JS引擎Nashorn" class="headerlink" title="废弃JS引擎Nashorn"></a>废弃JS引擎Nashorn</h4><p>废除Nashorn javascript引擎,在后续版本准备移除掉,有需要的可以考虑使用GraalVM</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java9&quot;&gt;&lt;a href=&quot;#Java9&quot; class=&quot;headerlink&quot; title=&quot;Java9&quot;&gt;&lt;/a&gt;Java9&lt;/h2&gt;&lt;h3 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h3&gt;&lt;p&gt;模块化有两个目标:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对JDK本身进行模块化&lt;/li&gt;
&lt;li&gt;提供一个应用程序可以使用的模块系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们是密切相关的,JDK的模块化可通过使用与应用程序开发人员使用的相同的模块系统来实现.通过引入模块化系统,使得Java真正的获得了对模块的三个核心原则的支持.&lt;br&gt;它带来的最重要的几个好处是:&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java Java9 Java10 Java11" scheme="https://zjjfly.github.io/tags/Java-Java9-Java10-Java11/"/>
    
  </entry>
  
  <entry>
    <title>Java7&amp;8新特性</title>
    <link href="https://zjjfly.github.io/2018/01/01/2018-1-1-Java7-8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://zjjfly.github.io/2018/01/01/2018-1-1-Java7-8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2018-01-01T01:32:28.000Z</published>
    <updated>2023-05-03T02:17:41.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java7新特性速览"><a href="#1-Java7新特性速览" class="headerlink" title="1.Java7新特性速览"></a>1.Java7新特性速览</h2><h3 id="1-1-语法变化"><a href="#1-1-语法变化" class="headerlink" title="1.1 语法变化"></a>1.1 语法变化</h3><h4 id="1-1-1-switch增强"><a href="#1-1-1-switch增强" class="headerlink" title="1.1.1 switch增强"></a>1.1.1 switch增强</h4><p>switch-case语法支持String类型了.在此之前只能用于byte、short、char、int以及它们的包装类型还有枚举类型.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;jjzi&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (name) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;zijj&quot;</span>:</span><br><span class="line">        assertTrue(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;jjzi&quot;</span>:</span><br><span class="line">        assertTrue(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        assertTrue(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="1-1-2-二进制字面量"><a href="#1-1-2-二进制字面量" class="headerlink" title="1.1.2 二进制字面量"></a>1.1.2 二进制字面量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">binary</span> <span class="operator">=</span> <span class="number">0b1000</span>;</span><br><span class="line">assertEquals(binary, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><h4 id="1-1-3-数字分隔符"><a href="#1-1-3-数字分隔符" class="headerlink" title="1.1.3 数字分隔符"></a>1.1.3 数字分隔符</h4><p>较长的数字可以用下划线分隔,便于代码的阅读.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1211_2313_2313L</span>;</span><br><span class="line">assertEquals(number, <span class="number">121123132313L</span>);</span><br></pre></td></tr></table></figure><h4 id="1-1-4-try-catch增强"><a href="#1-1-4-try-catch增强" class="headerlink" title="1.1.4 try-catch增强"></a>1.1.4 try-catch增强</h4><p>try-catch语法的变化主要有两点:</p><ol><li>try后面可以加括号,里面可以初始化对象,但这些对象要实现AutoClosable或Closeable接口.这些对象在语句try-catch结束之后,会自动关闭,不需要显示调用它们的<code>close()</code>方法.</li><li>catch可以一次捕获多种异常.<br>在此之前,一段读取文件内容并打印的代码,需要这样写:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">  br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(f));</span><br><span class="line">  String line;</span><br><span class="line">  <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">      System.out.println(line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;找不到文件&quot;</span>);;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    br.close();</span><br><span class="line">  &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新版本中只要这么写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>));</span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr))&#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | NullPointerException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-5-菱形语法"><a href="#1-1-5-菱形语法" class="headerlink" title="1.1.5 菱形语法"></a>1.1.5 菱形语法</h4><p>在7之前,声明一个带泛型的集合需要这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>现在只需要这么写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>因为编译器可以从前面的变量声明中推断出类型参数，所以后面的ArrayList可以不用写泛型参数，只用一对空着的尖括号就可以。</p><h3 id="1-2-新的API"><a href="#1-2-新的API" class="headerlink" title="1.2 新的API"></a>1.2 新的API</h3><h4 id="1-2-1-文件操作API"><a href="#1-2-1-文件操作API" class="headerlink" title="1.2.1 文件操作API"></a>1.2.1 文件操作API</h4><p>新的文件操作API提供了以下方便的功能:</p><ul><li>获取系统根目录</li><li>获取文件的目录层级</li><li>获取某个文件路径的子路径</li><li>根据相对路径得到绝对路径</li><li>计算两个文件的相对路径</li><li>目录下文件的过滤</li><li>目录的深层遍历</li><li>文件属性的操作,如文件权限,所属用户和组</li><li>移动和复制文件</li><li>软链接(symbol link)的支持</li><li>更简便的获取缓冲流</li><li>文件监控</li></ul><h4 id="1-2-2-AIO"><a href="#1-2-2-AIO" class="headerlink" title="1.2.2 AIO"></a>1.2.2 AIO</h4><p>提供了异步网络通道和异步文件通道,实现了真正的异步非阻塞IO.</p><h4 id="1-2-3-Fork-x2F-Join并发框架"><a href="#1-2-3-Fork-x2F-Join并发框架" class="headerlink" title="1.2.3 Fork&#x2F;Join并发框架"></a>1.2.3 Fork&#x2F;Join并发框架</h4><p>这个框架是为了实现线程池中任务的自动调度.把一个大的任务分解成一个个小任务,并发地执行它们,最后把它们的结果进行合并.类似MapReduce.</p><h4 id="1-2-4-更简单的反射API"><a href="#1-2-4-更简单的反射API" class="headerlink" title="1.2.4 更简单的反射API"></a>1.2.4 更简单的反射API</h4><p>Java7为间接调用方法引入了新的API,简化了方法的查找和调用.</p><h4 id="1-2-5-Objects工具类"><a href="#1-2-5-Objects工具类" class="headerlink" title="1.2.5 Objects工具类"></a>1.2.5 Objects工具类</h4><p>这个工具类提供了很多可以让重写<code>equals</code>,<code>hashCode</code>的非常简便的方法.</p><h2 id="2-Java8"><a href="#2-Java8" class="headerlink" title="2 Java8"></a>2 Java8</h2><h3 id="2-1-语法变化"><a href="#2-1-语法变化" class="headerlink" title="2.1 语法变化"></a>2.1 语法变化</h3><h4 id="2-1-1-lambda表达式"><a href="#2-1-1-lambda表达式" class="headerlink" title="2.1.1 lambda表达式"></a>2.1.1 lambda表达式</h4><p>lambda表达式是Java8最重要的特性.它在很多编程语言中都已经存在,如JS,Python,Haskell.它可以被看作是匿名函数的简洁表示.它没有名称,但有参数列表,有函数体和返回值.<br>对一个字符串数组按照字符串长度排序,在Java8之前需要这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt;&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2v)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> Integer.compare(o1.length(),o2.length());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] strings = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bcd&quot;</span>, <span class="string">&quot;ef&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(strings, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>());</span><br></pre></td></tr></table></figure><p>或者这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bcd&quot;</span>, <span class="string">&quot;ef&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(strings, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1.length(), o2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用lambda可以这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bcd&quot;</span>, <span class="string">&quot;ef&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(strings,</span><br><span class="line">    (String o1, String o2) -&gt; Integer.compare(o1.length(), o2.length()));</span><br></pre></td></tr></table></figure><p>其中,圆括号内的是参数,如果参数类型可以被推导出来,可以省略.实践中,大多数情况都不需要写.如果参数只有一个,可以省略圆括号.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventHandler&lt;ActionEvent&gt; listener = event -&gt; System.out.println(<span class="string">&quot;Click&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果lambda不需要参数,那么直接写一对空的括号.如果其中要写的代码不止一行,需要使用花括号.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>任何的只包含一个abstract方法的接口,我们都可以使用lambda来代替.这种接口被称为函数接口,比如Runnable和Comparator.它们的作用只是为了封装代码,因为Java中方法必须包装在类中.在Java8中,引入了@FunctionalInterface这个注解来标明这个接口是函数接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyFuncInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以不用这个注解,只要符合只包含一个抽象方法这个条件,都被认为是函数接口.实践中最好还是加上,这样编译器会检查这个接口是否符合作为函数接口的条件.<br><strong>lambda表达式实际还是接口的对象,任意一个lambda表达式都可以等价转换成现在所使用的API中对应的函数式接口.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; Integer.compare(first.length(), second.length());</span><br></pre></td></tr></table></figure><h4 id="2-1-2-方法引用"><a href="#2-1-2-方法引用" class="headerlink" title="2.1.2 方法引用"></a>2.1.2 方法引用</h4><p>有时候,我们要写的表达式其实已经有方法实现了,例如，你只想在按钮点击时打印event对象，使用刚刚学到的知识，代码这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).forEach(i-&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><p>这样写当然也很简洁,但其实我们直接把函数传递给<code>forEach</code>方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>其中,<code>System.out::println</code>是一个方法引用,等同于<code>x-&gt;System.out.println(x)</code>.再举一个例子,假如你想不区分大小写地对字符串进行排序,那么可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;dc&quot;</span>,<span class="string">&quot;be&quot;</span>&#125;,String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><p>方法引用有三种形式:</p><ul><li>对象::实例方法</li><li>类::静态方法</li><li>类::实例方法</li></ul><p>前两种情况,方法引用等同于接收参数并用这些参数去调用这个方法的lambda表达式,<code>System.out::println</code>等同<code>于x-&gt;System.out.println(x)</code>,<code>Math::pow</code>等同于<code>(x,y)-&gt;Math.pow(x,y)</code>.<br>第三种情况,传入的第一个参数会成为执行方法的对象,余下的参数传递给方法,例如<code>String::compareToIgnoreCase</code>,等价于<code>(x,y)-&gt;x.compareToIgnoreCase(y)</code>.<br><strong>和lambda表达式一样,方法引用也不会独立存在,它们经常被用于转换成函数式接口的实例.</strong></p><h4 id="2-1-3-构造器引用"><a href="#2-1-3-构造器引用" class="headerlink" title="2.1.3 构造器引用"></a>2.1.3 构造器引用</h4><p>它其实是方法引用的变种,语法和方法引用一样,只是方法名固定是new.如果有多个构造器.那么选哪个呢?和方法引用遇到的问题的答案一样,这取决于上下文.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; labels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">labels.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">labels.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">List&lt;Button&gt; buttons = labels.stream().map(Button::<span class="keyword">new</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>存在多个Button构造器,但是编译器会选择有一个String参数的构造器,因为它从上下文推测出调用构造器使用一个String.<br>你可以使用数组类型来建立构造器引用.比如<code>int[]::new</code>是带一个参数的构造器引用,这个参数就是数组长度.它等价于<code>x-&gt;new int[x]</code>.<br>使用数组构造器引用可以很好的克服一个Java的限制.我们知道Java有类型擦除机制,所以在设计库的时候,<code>new T[]</code>这样的语法是错误的,类型擦除会把它变成<code>new Object[]</code>.所以,Stream的一个方法<code>toArray,</code>它返回的类型是Object数组:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] btns = buttons.stream().toArray();</span><br></pre></td></tr></table></figure><p>但这样并不尽如人意,用户肯定是想要一个Button数组.通过数组构造器引用,Stream库解决了这个问题.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button[] btns= buttons.stream().toArray(Button[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h4 id="2-1-4-默认方法"><a href="#2-1-4-默认方法" class="headerlink" title="2.1.4 默认方法"></a>2.1.4 默认方法</h4><p>很多语言都将函数表达式应用到了集合库中.Java8同样如此.但是,Java的集合库是很早就有的,如果要给<code>Collection</code>接口添加新的方法,如<code>forEach</code>,那么所有实现了<code>Collection</code>接口的类都必须实现这个方法,这令人无法接受也没有必要.Java的设计者通过允许接口带有具体实现的方法来一劳永逸的解决这个问题,这些方法就叫做默认方法.下面是一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="string">&quot;JJZI&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认方法完全可以取代模板方法模式.</p><h4 id="2-1-5-接口中的静态方法"><a href="#2-1-5-接口中的静态方法" class="headerlink" title="2.1.5 接口中的静态方法"></a>2.1.5 接口中的静态方法</h4><p>Java8中，接口是可以添加静态方法的.技术上,这是完全没问题的,但这看起来违反了接口作为一个抽象定义的原则.至今,我们经常在相互一起使用的类中使用静态方法,如标准库中的Collection&#x2F;Collections或者Path&#x2F;Paths这样成对的接口和类.以Paths为例子,它有一些工程方法,用来产生Path.在Java8中,你可以把这些方法移到Path接口中,这样Paths就没必要存在了.<br>Java8中,很多接口已经添加了静态方法.例如,<code>Comparator</code>接口提供了一个很实用的比较方法,它接受一个键提取函数,并返回一个用来比较提取出的键的比较强.比如,要根据名称对Person对象进行比较,可以使用函数<code>Comparator.comparing(Person::getName)</code>.之前我们写过这样的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; Integer.compare(first.length(), second.length());</span><br></pre></td></tr></table></figure><p>其实下面这样写更简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = Comparator.comparingInt(String::length)</span><br></pre></td></tr></table></figure><h3 id="2-2-Stream"><a href="#2-2-Stream" class="headerlink" title="2.2 Stream"></a>2.2 Stream</h3><p>以前,我们要处理一个集合,需要使用for循环或Iterator来遍历这个集合,迭代的时候每次取一个元素,然后对这个元素做一些需要的操作.比如,计算字符串数组中长度大于10的字符串数量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">    <span class="keyword">if</span> (word.length()&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码有两个问题,一个是代码比较臃肿,还有一个是很难并行.Java8引入Stream就是解决这两个问题.下面是用Stream来实现同样的功能:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> words.stream().filter(w -&gt; w.length() &gt; <span class="number">10</span>).count();</span><br></pre></td></tr></table></figure><p>Stream看着和集合很像,但其实它们有着下面几大区别:</p><ul><li>Stream并不存储元素,它们可能是存储在底层的集合中或者根据需要生成.</li><li>Stream并不改变它们的数据源,相反.它们返回持有结果的新的Stream.</li><li>Stream操作可能是延迟执行的.这意味着它们会等到需要结果的时候才会执行.例如,如果你只需要前五个长度大于10的单词,那么filter方法会在第五次匹配之后停止过滤.因此,你甚至可以拥有无限的流.</li></ul><p>使用Stream一般分三个步骤:</p><ol><li>创建一个Stream.</li><li>在一个或多个步骤中，指定将初始的Stream转换成另一个Stream的中间操作.</li><li>使用一个终止操作产生结果.这个操作强制它之前的延迟操作立即执行,在这之后,Stream不能再被使用.</li></ol><h5 id="2-2-1-生成Stream"><a href="#2-2-1-生成Stream" class="headerlink" title="2.2.1 生成Stream"></a>2.2.1 生成Stream</h5><p>我们刚刚已经看到可以使用Java8加入Collection接口的stream方法把任何集合转变成Stream.如果你想要把数组转成Stream,可以使用静态方法Stream.of:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(content.split(<span class="string">&quot;[\\P&#123;L&#125;]+&quot;</span>));</span><br></pre></td></tr></table></figure><p>of还有一个可变的参数的版本,所以你可以用任意数量的参数来构造Stream:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; songs = Stream.of(<span class="string">&quot;gently&quot;</span>, <span class="string">&quot;down&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;stream&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建一个空的Stream:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; silence = Stream.empty();</span><br></pre></td></tr></table></figure><p>Stream接口有两个静态方法用来创建无限<code>Stream.generate</code>方法接受一个无参数的函数(或者,技术上说,一个Supplier<T>接口的对象).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; echos = Stream.generate(() -&gt; <span class="string">&quot;Echo&quot;</span>);</span><br></pre></td></tr></table></figure><p>而要产生像”0 1 2 3 …“这样的序列,使用<code>iterate</code>方法.它接受一个初始值和一个函数(技术上来说,一个UnaryOperation<T>对象),并且重复的调用该函数,参数就是Stream中的前一个元素.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integers = Stream.iterate(<span class="number">0</span>, i-&gt;i+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>静态方法Files.lines返回包含文件所有行的Stream.Stream接口有一个AutoCloseable父接口.当Stream的close方法被调用的时候,底层的文件也会被关闭.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream&lt;String&gt; lines=Files.lines(Paths.get(<span class="string">&quot;gradlew&quot;</span>))) &#123;</span><br><span class="line">    System.out.println(lines.count());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要得到可以并行的Stream,可以调用Collection接口的<code>parallelStream()</code>方法.并行Stream一般来说性能比一般的Stream高,特别是Stream的元素较多的时候.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; parallelIntegers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).parallelStream();</span><br></pre></td></tr></table></figure><p>调用Stream的<code>limit(n)</code>方法,返回含有n个元素的新的流(或者返回原来的流如果原来流的大小比n小).这个方法对于把无限的流切成一定大小是很有用的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Double&gt; randoms = Stream.generate(Math::random).limit(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>Stream的skip(n)方法和它正好相反,它会丢弃前n个元素.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">0</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).skip(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>还可以用Stream类的静态方法concat把两个流连接起来.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; combined = Stream.concat(Stream.of(<span class="string">&quot;Hello&quot;</span>), Stream.of(<span class="string">&quot;World&quot;</span>));</span><br></pre></td></tr></table></figure><p>还有一个peek方法.它生成的流中的元素和原来的流完全一样,但是每次在其中取一个元素都会调用一个函数,这个方法对于debug是很方便.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] powers = Stream.iterate(<span class="number">1</span>, integer -&gt; integer * <span class="number">2</span>).peek(e -&gt; System.out.println(<span class="string">&quot;Fetching:&quot;</span> + e)).limit(<span class="number">20</span>).toArray();</span><br></pre></td></tr></table></figure><p>当某个元素真正被访问了，才会打印出来一个消息。这可以验证对流的处理是lazy的。</p><h4 id="2-2-2-转换Stream"><a href="#2-2-2-转换Stream" class="headerlink" title="2.2.2 转换Stream"></a>2.2.2 转换Stream</h4><p>主要介绍<code>filter</code>,<code>map</code>,<code>forEach</code>,<code>flatMap</code>,<code>distinct</code>,<code>reverse</code>这几个常用的转换方法.filter这个转换方法,它会生成一个新的流,其中包含了满足特定条件的所有元素.filter的参数是一个<code>Predicate&lt;T</code>&gt;,这是一个从T到boolean的函数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; wordsList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">Stream&lt;String&gt; words = wordsList.stream();</span><br><span class="line">Stream&lt;String&gt; longWords = words.filter(s -&gt; s.length() &gt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>我们通常会想对一个流中的值进行某种形式的转换,这就需要使用<code>map</code>方法,传递给它一个执行转换的函数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; lowcaseWords = words.map(String::toLowerCase);</span><br></pre></td></tr></table></figure><p>如果map使用的转换函数返回的是一个Stream,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">characterStream</span><span class="params">(String s</span></span><br><span class="line"><span class="params">    List&lt;Character&gt; result = new ArrayList&lt;&gt;()</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        result.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.stream();</span><br><span class="line">&#125;</span><br><span class="line">Stream&lt;Stream&lt;Character&gt;&gt; result = words.map(TransformMethod::characterStream);</span><br></pre></td></tr></table></figure><p>那么<code>map</code>返回的是一个包含流的流,如果需要的是包含字符的流,那么需要使用<code>flatMap</code>而不是<code>map</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; characterStream = words.flatMap(TransformMethod::characterStream);</span><br></pre></td></tr></table></figure><p>目前介绍的这几个方法都是无状态的转换,即当你从一个已过滤的或已映射过的流中获取一个元素的时候,它的结果并不依赖于之前获取的元素.除此之前,也有一些有状态的转换方法.例如<code>distinct</code>方法,它根据原来的流中的元素返回一个剔除了重复的元素的流.这显然是必须记住已经读取的元素的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; uniqueWords = Stream.of(<span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;gently&quot;</span>).distinct();</span><br></pre></td></tr></table></figure><p>sorted方法必须遍历整个流,并在产生任何元素之前就对其进行排序,毕竟,最小的元素可以位于最后.它不能应用于一个无限长的流.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; longestString=words.sorted(Comparator.comparingInt(String::length).reversed());</span><br></pre></td></tr></table></figure><h4 id="2-2-3-Optional"><a href="#2-2-3-Optional" class="headerlink" title="2.2.3 Optional"></a>2.2.3 Optional</h4><p>我们接下来要介绍的是流的聚合方法,但是在此之前,需要了解Java8另一个重要的类:Optional,因为很多聚合方法返回的类型就是<code>Optional&lt;T&gt;</code>.<code>Optional&lt;T&gt;</code>是一种更好的表明方法的返回值可能是null的方式,这很好的避免了抛出<code>NullPointerException</code>,但你需要正确的使用它.<br>先看一个错误的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; optionalValue = ...; </span><br><span class="line">optionalValue.get().someMethod()</span><br></pre></td></tr></table></figure><p>其中,<code>get()</code>方法是取出其中分装的对象.它并不比下面的代码安全:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> ...; </span><br><span class="line">value.someMethod();</span><br></pre></td></tr></table></figure><p>再看一个:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (optionalValue.isPresent()) optionalValue.get().someMethod();</span><br></pre></td></tr></table></figure><p>其中,<code>isPresent</code>测试是否分装了值.它并不比下面的代码更简洁:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value != <span class="literal">null</span>) value.someMethod();</span><br></pre></td></tr></table></figure><p><strong>高效的使用Optional的关键是,使用一个接收正确的值或者产生替代值的方法.</strong><br>方法<code>ifPresent</code>接收一个函数,如果存在可选值,那么它会被传递给这个函数,如果没有,什么都不会发生.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optionalValue.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p><code>ifPresent</code>没有返回值,如果你希望对结果进行处理,用map方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Optional&lt;Boolean&gt; added = optionalValue.map(results::add);</span><br></pre></td></tr></table></figure><p><code>added</code>可能有三种值:封装着true或false的Optional对象如果<code>optionalValue</code>中有值的话,否则的话是一个空的Optional对象.这个map方法和流的map方法是类似的,你可以把Optional看成是一个大小是0或1的流.但如果传入的方法返回值类型是<code>Optional&lt;U&gt;</code>,那么<code>map</code>返回的类型就是<code>Optional&lt;Optional&lt;U&gt;&gt;</code>,而你只想得到<code>Optional&lt;U&gt;</code>,那么使用<code>flatMap</code>,这也是和流类似的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Double&gt; <span class="title function_">square</span><span class="params">(Double x)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==<span class="number">0</span>?Optional.empty():Optional.of(Math.sqrt(x));</span><br><span class="line">&#125;</span><br><span class="line">Optional&lt;Double&gt; result = Optional.of(<span class="number">4.0</span>).flatMap(OptionalType::square);</span><br></pre></td></tr></table></figure><p>另一个使用可选值的策略是当没有值存在时产生一个替代值.通常,当没有匹配项时,你会想要使用一个默认值,例如空字符串.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> optionalString.orElse(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>你也可以调用函数来计算默认值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result=optionalString.orElseGet(() -&gt; System.getProperty(<span class="string">&quot;user.dir&quot;</span>))</span><br></pre></td></tr></table></figure><p>或者，你想在没有值的时候抛出异常:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">error</span> <span class="operator">=</span> optionalString.orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-4-聚合方法"><a href="#2-2-4-聚合方法" class="headerlink" title="2.2.4 聚合方法"></a>2.2.4 聚合方法</h4><p>我们之前已经见过一个聚合方法<code>count</code>,还有简单的聚合方法如<code>min</code>和<code>max</code>,它们返回类型是<code>Optional&lt;T&gt;</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; largest = sortedWords.max(String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><p><code>findFirst</code>方法返回集合中的第一个值,返回的也是<code>Optional&lt;T&gt;</code>.它通常和<code>filter</code>方法结合使用.比如,返回第一个以Q开头的单词:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; startWithQ = words.filter(s -&gt; s.startsWith(<span class="string">&quot;Q&quot;</span>)).findFirst();</span><br></pre></td></tr></table></figure><p>如果你不在乎是否是第一个,只想要任意的匹配项,可以使用f<code>indAny</code>,它在你并行地处理流的时候非常高效,因为在任意片段中找到了第一个匹配项就会结束整个计算了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; startWithQ = words.parallel().filter(s -&gt; s.startsWith(<span class="string">&quot;Q&quot;</span>)).findAny();</span><br></pre></td></tr></table></figure><p>如果你只想知道流中是否有匹配的元素,使用<code>anyMatch</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">aWordStartsWithQ</span> <span class="operator">=</span> words.parallel().anyMatch(s -&gt; s.startsWith(<span class="string">&quot;Q&quot;</span>));</span><br></pre></td></tr></table></figure><p>还有两个方法<code>allMatch</code>和<code>noneMatch</code>,它们分别在所有元素或没有元素匹配的时候返回true.</p><p>最重要的聚合方法是<code>reduce</code>.它有三种形式.<br>第一种接收一个二元函数,并不断应用它.第一次的参数是是流的前两个元素,然后是第一次调用的结果和流的第三个元素,依次类推,直到流的最后.这个方法返回的是一个Optional,因为流可能是空的.下面是一个求流的元素的和的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; values = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; sum = values.reduce((x, y) -&gt; x + y)</span><br></pre></td></tr></table></figure><p>这个函数需要是满足结合律的,也即是说这个操作和你组合元素的顺序无关,(x op y) op z &#x3D; x op (y op z).这样就允许使用并行流进行高效的聚合.在实践中,有很多有用的结合操作,例如和,积,字符串连接,最大值和最小值,并集和交集.<br>第二种形式,相比第一个形态多了一个参数,作为初始值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> values.reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure><p>现在假设你有一个包含多个对象的流,你想要对对象们的某个属性求和,比如流中字符串的总长.你不能使用简单形式的reduce方法,因为它需要的一个函数<code>(T,T)-&gt;T</code>,其中参数类型和返回值类型都必须是一样的,而现在的情况下,这两种类型是不同的,流的元素的类型是字符串,而累积结果的类型是整型.幸好有另一种形式的reduce可以处理这个情况.下面是它的参数列表:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U , BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; , BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数是初始值,第二个参数是一个累加器函数,最后一个函数是为了在并行计算合并多个子结果的时候使用的.下面是计算流中字符串总长的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">words.reduce(<span class="number">0</span>, (s, word) -&gt; s + word.length(), (total, subtotal) -&gt; total + subtotal)</span><br></pre></td></tr></table></figure><p>但实践中,不会大量使用<code>reduce</code>方法.就拿上面这个例子来说,更好的方法是先把字符流映射到数字流,然后求和.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">words.mapToInt(String::length).sum()</span><br></pre></td></tr></table></figure><h4 id="2-2-5-收集结果"><a href="#2-2-5-收集结果" class="headerlink" title="2.2.5 收集结果"></a>2.2.5 收集结果</h4><p>当你对一个流进行了处理,你通常想要看到结果而不是把它们聚合成一个值.你可以调用iterator方法,生成一个旧式的迭代器用来访问元素.或者调用toArray获取流元素组成的一个数组,就像之前看到.<br>但如果你想要把结果放到一个List或者Set中,那么你要用<code>collect</code>方法.它有三个参数:</p><ol><li>一个生成目标对象实例的生产者,比如,一个HashSet的构造器.</li><li>一个把元素添加到目标对象的累加器.例如,add方法.</li><li>一个把两个对象合成一个的组合器,如addAll方法.</li></ol><p>注意,目标对象不一定是集合,也可以是StringBuilder或一个跟踪数量和总和的对象.下面是产生一个HashSet的collect的写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; nums=Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>);</span><br><span class="line">nums.collect(HashSet::<span class="keyword">new</span>, HashSet::add, HashSet::addAll);</span><br></pre></td></tr></table></figure><p>实践中,你不需要这样写,因为有一个便利的<code>Collector</code>接口代替这三个函数,并且有包含了很多常用的Collector的类Collectors.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><p>如果想要控制获得的set类型,可以像下面这样调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><p>如果想要通过拼接把流中的所有字符串收集起来,你可以调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words=Stream.of(<span class="string">&quot;what&quot;</span>, <span class="string">&quot;which&quot;</span>, <span class="string">&quot;where&quot;</span>,<span class="string">&quot;when&quot;</span>);</span><br><span class="line">words.collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure><p>如果你想要对流进行聚合求和,平均值,最大值v,最小值,可以使用<code>Collectors</code>中的<code>summarizing</code>方法.这些方法接收一个可以把流中的对象映射到数字的函数,返回一个类型是<code>(Int|Long|Double)SummaryStatistics</code>的对象,它们带有获取和,平均值,最大值,最小值的方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span>words.collect(Collectors.summarizingInt(String::length));</span><br><span class="line">statistics.getAverage();</span><br><span class="line">statistics.getMax();</span><br><span class="line">statistics.getMin();</span><br><span class="line">statistics.getSum();</span><br></pre></td></tr></table></figure><p>如果你只是想要打印流中的元素或者把它们放入数据库,可以使用<code>forEach</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>你传入的这个函数会被应用到流中的每个元素上.在一个并行流中,你需要保证这个函数式可以被并发地执行的.并行流中的元素可能会被以任意的顺序遍历,如果你想按照原始的顺序执行,调用<code>forEachOrdered</code>.当然,这样你就放弃了并行带来的好处.<code>forEach</code>和<code>forEachOrdered</code>方法都是终结操作,调用它们之后,你无法再使用流了.如果你想继续使用流,使用之前提到的<code>peek</code>.</p><h4 id="2-2-6-将结果收集到Map"><a href="#2-2-6-将结果收集到Map" class="headerlink" title="2.2.6 将结果收集到Map"></a>2.2.6 将结果收集到Map</h4><p>假设你有一个<code>Person</code>的流,你想把元素收集到一个Map以便可以使用它们的ID来进行查找.你可以使用<code>Colletors.toMap</code>方法,它有两个函数参数,分别用来生成Map的键和值.例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, String&gt; idToName = people.collect(Collectors.toMap(Person::getId, Person::getName));</span><br></pre></td></tr></table></figure><p>但一般情况下,Map的值应该是实际的对象,所以使用Function.identity()作为第二个参数,这个函数接受一个参数,然后直接返回它:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; idToPerson = people.collect(Collectors.toMap(Person::getId, Function.identity()));</span><br></pre></td></tr></table></figure><p>如果多个元素有相同的键,那么收集器会抛出<code>IllegalStateException</code>异常.但你可以通过提供第三个函数参数重写这个行为.这个函数的参数是已有值和新的值,你可以返回它们中的一个或者根据它们另外产生一个值来返回.这里,我们构造一个map,对于系统的支持的所有语言,以其默认语言环境中的名字作为键,以其本地化的名字作为值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Locale&gt; locales = Stream.of(Locale.getAvailableLocales());</span><br><span class="line">Map&lt;String, String&gt; languageNames = locales.collect(Collectors.toMap(</span><br><span class="line">        Locale::getDisplayLanguage,</span><br><span class="line">        l -&gt; l.getDisplayLanguage(l),</span><br><span class="line">        (existingValue, newValue) -&gt; existingValue));</span><br></pre></td></tr></table></figure><p>但是,如果我们希望知道指定国家的所有语言,那么我们需要得到一个<code>Map&lt;String,Set&lt;String&gt;&gt;</code>对象.首先,我们把每种语言存到单个集中,当发现指定国家的新的语言时,我们就将已有值和新值组合成一个新的集合.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;String&gt;&gt; countryLanguageSets = locales</span><br><span class="line">        .collect(Collectors.toMap(Locale::getDisplayCountry, l -&gt; Collections.singleton(l.getDisplayLanguage()),</span><br><span class="line">                                  (a, b) -&gt; &#123;</span><br><span class="line">                                      HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(a);</span><br><span class="line">                                      set.addAll(b);</span><br><span class="line">                                      <span class="keyword">return</span> set;</span><br><span class="line">                                  &#125;));</span><br></pre></td></tr></table></figure><p>如果你想要的是一个TreeMap，那么你需要提供一个构造器引用作为第四个参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Locale&gt; locales = Stream.of(Locale.getAvailableLocales());</span><br><span class="line">Map&lt;String, String&gt; languageNames = locales.collect(Collectors.toMap(</span><br><span class="line">        Locale::getDisplayLanguage,</span><br><span class="line">        l -&gt; l.getDisplayLanguage(l),</span><br><span class="line">        (existingValue, newValue) -&gt; existingValue,</span><br><span class="line">        TreeMap::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><p>对于上面的三种<code>toMap</code>方法,都有对应的<code>toConcurrentMap</code>方法,用来产生一个ConcurrentMap.</p><h4 id="2-2-7-分组和分片"><a href="#2-2-7-分组和分片" class="headerlink" title="2.2.7 分组和分片"></a>2.2.7 分组和分片</h4><p>对有共同特性的值进行分组是是很常见的需求,<code>groupingBy</code>方法就是专门用于分组的.还是对国家语言分组的问题,使用<code>groupingBy</code>方法的写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Locale&gt;&gt; country2Locales= locales.collect(Collectors.groupingBy(Locale::getCountry));</span><br></pre></td></tr></table></figure><p>当分类函数是一个Predicate函数时，流元素会被分为两组,一组是函数会返回true的元素,另一组是返回false的元素.这种情况下,使用<code>partitionBy</code>方法.例如,把所有语言环境分为两组,一组是使用英语一组使用的是其他语言:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Locale&gt;&gt; englishAndOtherLocales = locales.collect(partitioningBy(l -&gt; l.getLanguage().equals(<span class="string">&quot;en&quot;</span>)));</span><br><span class="line">List&lt;Locale&gt; englishLocales = englishAndOtherLocales.get(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><code>groupingBy</code>方法生成的map的值是list,如果你想要使用某种方式处理这些list的时候,你要提供一个downstream收集器.例如,你想要set而不是list,你可以使用<code>Collectors.toSet</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;Locale&gt;&gt; countryToLocaleSet = locales.collect(groupingBy(Locale::getCountry, toSet()));</span><br></pre></td></tr></table></figure><p>还有若干其他的收集器可以用于分好组的元素的处理:</p><ul><li><code>counting</code>产生被收集的元素的个数,例如:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; countryToLocaleCounts = locales.collect(groupingBy(Locale::getCountry, counting()));</span><br></pre></td></tr></table></figure><ul><li>summing(Int|Long|Double)接受一个函数参数,并应用这个函数到各个分组的元素,生成它们的合,例如:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; stateToPopulation = cities.collect(groupingBy(City::getState, summingInt(City::getPopulation)));</span><br></pre></td></tr></table></figure><ul><li>maxBy和minBy接收一个比较器并产生各个分组的元素的最大值和最小值.例如:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Optional&lt;City&gt;&gt; stateToLargestCity = cities</span><br><span class="line">        .collect(groupingBy(City::getState, maxBy(Comparator.comparingInt(City::getPopulation))));</span><br></pre></td></tr></table></figure><ul><li><code>mapping</code>应用一个函数到各个分组,它还需要另一个收集器处理之前的结果.还记得上一个章节中的收集国家的所有语言到一个set的问题吗？<code>mapping</code>方法可以提供一个更加漂亮的解决方案:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;String&gt;&gt; countryToLanguages = locales</span><br><span class="line">        .collect(groupingBy(Locale::getDisplayCountry, mapping(Locale::getDisplayLanguage, toSet())));</span><br></pre></td></tr></table></figure><ul><li>最后,<code>reducing</code>方法可以对downst的元素应用一个聚合函数.它有三种形式,这其实和之前的<code>reduce</code>的三种形式是对应的.下面的代码可以获取每个州以及州的所有城市名拼接成的字符串的Map:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; stateToCityNames = cities.collect(groupingBy(City::getState, reducing(<span class="string">&quot;&quot;</span>, </span><br><span class="line">        City::getName, (c1, c2) -&gt; c1.length() == <span class="number">0</span> ? c2 : s + <span class="string">&quot;,&quot;</span> +c2)));</span><br></pre></td></tr></table></figure><p>和reduce一样,reducing用的并不多.这个例子中,我们可以更自然的达到目的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stateToCityNames = cities.collect(groupingBy(City::getState, mapping(City::getName, joining(<span class="string">&quot;,&quot;</span>))));</span><br></pre></td></tr></table></figure><p>显然,使用downstream收集器会产生非常复杂的代码.所以,你应该只在处理<code>groupingBy</code>或<code>partitionBy</code>产生的分组的时候使用它们,其他情况,只需要使用诸如<code>map</code>,<code>reduce</code>,<code>count</code>,<code>max</code>或<code>min</code>这些简单的方法即可.</p><h4 id="2-2-8-原生类型流"><a href="#2-2-8-原生类型流" class="headerlink" title="2.2.8 原生类型流"></a>2.2.8 原生类型流</h4><h2 id="原生类型流"><a href="#原生类型流" class="headerlink" title="原生类型流"></a>原生类型流</h2><p>目前为止,我们都是把整数收集到一个<code>Stream&lt;Integer&gt;</code>,尽管把每个整形放入包装对象显然是低效的做法.其他原始类型也是一样的.为此,提供了特化类型<code>IntStream</code>,<code>LongStream</code>和<code>DoubleStream</code>,它们直接存储原始类型值,不需要包装.下面是对应关系:</p><ul><li>存放short、char、byte、int和boolean类型的值,使用<code>IntStream</code></li><li>存放float和double类型的值,使用<code>DoubleStream</code>.</li><li>存放long类型的值,使用<code>LongStream</code>.</li></ul><p>要创建一个IntStream,可以调用IntStream.of和Arrays.stream方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">stream = Arrays.stream(values);</span><br></pre></td></tr></table></figure><p>和对象流一样,IntStream和LongStream提供了静态方法range和rangeClosed来生成步数为1的数列.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">zeroToNinetyNine</span> <span class="operator">=</span> IntStream.range(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">zeroToHundred</span> <span class="operator">=</span> IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>当你有一个对象流,你可以使用<code>mapToInt</code>,<code>mapToDouble</code>,<code>mapToLong</code>方法把它转换成原生类型流.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words=Stream.of(<span class="string">&quot;what&quot;</span>, <span class="string">&quot;which&quot;</span>, <span class="string">&quot;where&quot;</span>,<span class="string">&quot;when&quot;</span>);</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">lengths</span> <span class="operator">=</span> words.mapToInt(String::length);</span><br></pre></td></tr></table></figure><p>使用boxed方法把原生类型流转换为它们的封装对象流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integers = IntStream.range(<span class="number">0</span>, <span class="number">100</span>).boxed();</span><br></pre></td></tr></table></figure><p>Random类的ints,longs和doubles方法返回随机数的原生类型流,但要注意,这些流是无限流.它们一般用于生成若干个随机数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">randomInts</span> <span class="operator">=</span> random.ints();</span><br><span class="line"><span class="type">DoubleStream</span> <span class="variable">randomDoubles</span> <span class="operator">=</span> random.doubles();</span><br><span class="line"><span class="type">LongStream</span> <span class="variable">randomLongs</span> <span class="operator">=</span> random.longs();</span><br></pre></td></tr></table></figure><h4 id="2-2-9-并行流"><a href="#2-2-9-并行流" class="headerlink" title="2.2.9 并行流"></a>2.2.9 并行流</h4><p>流使对大量运算并行化非常容易.这一过程基本是自动的,但你也需要遵守一些规则.首先,你要有一个并行流.除了<code>Collection.parallelStream</code>方法,流操作生成的都是顺序流.<code>parellel</code>方法可以把任意顺序流转换成并行流.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; parallelIntegers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>).parallelStream();</span><br><span class="line">Stream&lt;String&gt; parallelWords = Stream.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>).parallel();</span><br></pre></td></tr></table></figure><p>只要流是处于并行模式,当执行终结方法的时候,所有的中间流操作都会被并行化.并行化的目的,是希望能得到和顺序执行一样的结果,<strong>所以操作必须是无状态和顺序无关,并且是线程安全的</strong>,这很重要.<br>默认情况下,从有序集合(数组或列表),范围值,生成器以及迭代器,或者Stream.sorted所产生的流,都是有序的.对这些流操作的结果也是按照顺序累计的,是完全可预测的.<br>当不考虑顺序时,某些操作可能会更加高效地并行化.通过调用<code>stream.unordered</code>方法,你可以表明你不关心顺序.你还可以通过放弃有序来加快<code>limit</code>方法的速度.如果你想要一个流中任意n个元素,可以这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.parallel().unordered().limit(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>注意,<strong>当你执行一个流操作的时候,你并不会修改流底层的集合(即使这个操作是线程安全的)</strong>.准确一点说,由于中间流操作是延迟执行的,所以在终结操作执行的之前改变集合是可能的.例如,下面的代码是正确的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(<span class="string">&quot;BEGIN&quot;</span>,<span class="string">&quot;RUNNING&quot;</span>);</span><br><span class="line">words.add(<span class="string">&quot;END&quot;</span>);</span><br><span class="line"><span class="keyword">assert</span> <span class="number">3</span> == words.distinct().count();</span><br></pre></td></tr></table></figure><h4 id="2-2-10-函数式接口"><a href="#2-2-10-函数式接口" class="headerlink" title="2.2.10 函数式接口"></a>2.2.10 函数式接口</h4><p>在本章中,已经看了很多参数为函数的方法.例如<code>Stream.filter</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure><p>查看javadoc,发现<code>Predicate</code>是一个函数式接口,只包含一个返回boolean的非默认方法.在实际开发中,一般会传递lambda或者方法引用到<code>filter</code>方法.所以这个方法的名字并不重要,重要的是返回的是boolean值.你在看文档的时候,只要记住<code>Predicate</code>是一个返回boolean值的函数就行.<br>下面的图列举了一些常用的函数式接口:</p><div align="center"><img width="660" height="520" src="https://zjjfly.github.io/images/20170903/java8-2-1.png"/></div>而对于原始类型,也有些专门的函数式接口,这样可以省去了自动装箱的开销:<div align="center"><img width="625" height="379" src="https://zjjfly.github.io/images/20171010/java8-3-2.jpg"/></div>假如你想要编写一个匹配特定条件的文件,应当使用描述性的`java.io.FileFilter`类,还是一个`Predicate<File>`呢?强烈推荐使用`Predicate<File>`.只有一种情况下可以不使用它,那就是你已经有了很多生成FileFilter实例的方法.选择函数式接口的一个原则是**选择尽量通用的**,这也是 _Effective Java_ 第三版推荐的做法,具体有哪些函数可以看`java.util.function`包中定义的接口.### 2.3 增强的并发API* 添加了`updateAndGet`和`accumulateAndGet`方法,可以更容易的更新原子变量.* 添加了`LongAccumulator`和`DoubleAccumulator`,在高并发的环境中,比`AtomicLong`和`AtomicDouble`效率高.* 为`ConcurrentHashMap`添加了`merge`和`compute`方法,可以更容易的更新`ConcurrentHashMap`.* 现在`ConcurrentHashMap`提供了对键,值,键值对以及元素项的各类操作,例如`search`,`reduce`和`forEach`.* 集合视图允许将`ConcurrentHashMap`作为一个`Set`来使用.* `Arrays`类新添加了排序,填充和前缀操作的并行方法.* `CompletableFuture<T>`允许你更容易的编写异步操作.<h3 id="2-4-其他更新"><a href="#2-4-其他更新" class="headerlink" title="2.4 其他更新"></a>2.4 其他更新</h3><ul><li>新的JavaFx API.</li><li>新的时间和日期API,它比<code>Calender</code>更易用.</li><li>新的JavaScript引擎Nashorn.</li><li><code>String.join(&quot;,&quot;,a,b,c)</code>,提供了方便的分隔符字符串拼接的方法.</li><li><code>Integer</code>类现在支持无符号数学运算</li><li><code>Math</code>添加了检测整数是否溢出.</li><li><code>Collection</code>和<code>List</code>中提供了很多新方法.</li><li>对Base64提供了官方支持</li><li>注解可以重复使用,并且可以用在类型上.</li><li><code>Objects</code>提供了对null的检查.</li><li><code>java.util.Logger</code>新增了一些方法,并且可以传入一个<code>Supplier&lt;T&gt;</code>参数来实现延迟构造信息.</li><li><code>Pattern</code>类增加了<code>splitAsStream</code>方法,可以将一个<code>CharSequence</code>按照正则表达式分隔,返回一个<code>Stream</code>.</li><li>JDBC升级到版本4.2</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-Java7新特性速览&quot;&gt;&lt;a href=&quot;#1-Java7新特性速览&quot; class=&quot;headerlink&quot; title=&quot;1.Java7新特性速览&quot;&gt;&lt;/a&gt;1.Java7新特性速览&lt;/h2&gt;&lt;h3 id=&quot;1-1-语法变化&quot;&gt;&lt;a href=&quot;#1-1-语法变化&quot; class=&quot;headerlink&quot; title=&quot;1.1 语法变化&quot;&gt;&lt;/a&gt;1.1 语法变化&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-switch增强&quot;&gt;&lt;a href=&quot;#1-1-1-switch增强&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 switch增强&quot;&gt;&lt;/a&gt;1.1.1 switch增强&lt;/h4&gt;&lt;p&gt;switch-case语法支持String类型了.在此之前只能用于byte、short、char、int以及它们的包装类型还有枚举类型.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;jjzi&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;zijj&amp;quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        assertTrue(&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;jjzi&amp;quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        assertTrue(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        assertTrue(&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Java Java7 Java8" scheme="https://zjjfly.github.io/tags/Java-Java7-Java8/"/>
    
  </entry>
  
  <entry>
    <title>快学Java8 第三章</title>
    <link href="https://zjjfly.github.io/2017/10/10/%E5%BF%AB%E5%AD%A6Java8%20%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>https://zjjfly.github.io/2017/10/10/%E5%BF%AB%E5%AD%A6Java8%20%E7%AC%AC%E4%B8%89%E7%AB%A0/</id>
    <published>2017-10-10T01:32:28.000Z</published>
    <updated>2023-05-03T02:16:39.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h2><p><strong>所有的lambda表达式都是延迟执行的</strong>.如果你希望立刻执行,就没必要使用lambda表达式了.延迟执行的原因有很多,例如:</p><ul><li>在另一个线程中运行</li><li>多次运行代码</li><li>在某个算法的正确时间点上运行代码(例如排序算法中的比较操作)</li><li>只有在需要的时候运行代码</li></ul><span id="more"></span><p>当你使用lambda的时候,要考虑一下希望达到什么效果.来看一个简单的例子.假如你要记录一个事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.info(<span class="string">&quot;x: &quot;</span>+x+<span class="string">&quot;,y: &quot;</span>+y);</span><br></pre></td></tr></table></figure><p>如果日志级别设置成忽略INFO消息的话,这个字符串还是会被计算并传递给<code>info</code>方法,然后再确定是否打印日志.为什么不能先确定是否要打印,然后再把字符串拼接起来呢？这种情景就需要使用lambda了.惯用的办法是将代码包装成一个无参数的lambda表达式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;<span class="string">&quot;x: &quot;</span>+x = <span class="string">&quot;,y: &quot;</span>+y</span><br></pre></td></tr></table></figure><p>现在我们需要编写一个方法,它可以接受lambda表达式,检查它是否应该被执行,如果需要的话才执行.要接受lambda表达式,需要选择一个函数式接口,这里我们选择<code>Supplier&lt;String&gt;</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(Logger logger,Supplier&lt;String&gt; message)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(logger.isLoggable(Level.INFO))&#123;</span><br><span class="line">        logger.info(message.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟记录日志消息是一个很好的想法,<strong>在Java8的API中,<code>java.util.logging.Logger</code>的<code>info</code>方法和其他日志方法都可以接受<code>Supplier&lt;String&gt;</code>作为参数</strong>.</p><h2 id="lambda表达式的参数"><a href="#lambda表达式的参数" class="headerlink" title="lambda表达式的参数"></a>lambda表达式的参数</h2><p>下面的方法接受一个<code>action</code>,并对其多次重复执行这个<code>action</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">repeat</span><span class="params">(<span class="type">int</span> n, IntConsumer action)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        action.accept(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么使用<code>IntConsumer</code>而不是<code>Runnable</code>对象呢,因为我们可能需要告诉<code>action</code>它发生在哪次迭代.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat(<span class="number">10</span>, i -&gt; System.out.println(<span class="string">&quot;Countdown: &quot;</span>+(<span class="number">9</span>-i)));</span><br></pre></td></tr></table></figure><p>另一个例子是时间监听器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnAction(event -&gt; action);</span><br></pre></td></tr></table></figure><p><code>event</code>对象包含了<code>action</code>可能需要的信息.<br>一般来说,在设计方法的时候会希望把它需要的所有信息作为参数传递进去.但是,<strong>如果这些参数很少用到,那么可以考虑第二个版本,不强制用户传递那些不需要的参数.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">repeat</span><span class="params">(<span class="type">int</span> n, Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择一个函数式接口"><a href="#选择一个函数式接口" class="headerlink" title="选择一个函数式接口"></a>选择一个函数式接口</h2><p>在大多数情况下,函数类型是结构化的.例如把两个字符串映射为一个整数的函数,需要使用一个类似于<code>Function2&lt;String,String,Integer&gt;</code>或者<code>(String,Stirng)-&gt;int</code>类型.不过<strong>在Java中,你需要使用<code>Comparator&lt;String&gt;</code>这样的函数式接口来表明函数的目的,在编程语言的理论中,这被称为名义类型.</strong><br>当然,在很多情况下,我们希望接受任意的函数,而不是某种特定语义的函数.因此,Java8提供很多一般的函数类型,<strong>我们要尽可能使用它们</strong>.</p><div align="center"><img width="472" height="587" src="https://zjjfly.github.io/images/20171010/java8-3-1.jpg"/></div>假如你想要编写一个匹配特定条件的文件,应当使用描述性的`java.io.FileFilter`类,还是一个`Predicate<File>`呢？强烈推荐使用`Predicate<File>`.只有一种情况下可以不使用它,那就是你已经有了很多生成`FileFilter`实例的方法.**选择函数式接口的一个原则是选择尽量通用的**大多数标准的函数式接口都拥有用来生成或组合函数的静态方法.例如,`Predicate.isEqual(a)`同`a::equals`一样(假设a不为null).此外,它们还有用来组合`Predicate`的默认方法`and`,`or`,`negate`.例如`Predicate.is(a).or(Predicate.isEqual(b))`同`x->a.equals(x)||b.equals(x)`一样.下面列举了专门为原始类型int,long和double提供的函数式接口.用这些函数式接口可以减少自动装箱.<div align="center"><img width="625" height="379" src="https://zjjfly.github.io/images/20171010/java8-3-2.jpg"/></div>有些时候,**标准库中找不到合适的接口,你才需要自己创建一个函数式接口**.例如你想要修改一种图片的颜色,需要实现一个根据像素在图片中的位置来计算新的颜色,那么你可以这样定义接口:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ColorTransformer</span>&#123;</span><br><span class="line">    Color <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,Color colorAtXY)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>Java8中所谓的返回一个函数实际是返回一个函数式接口的对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> UnaryOperator&lt;Color&gt; <span class="title function_">brighten</span><span class="params">(<span class="type">double</span> factor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c -&gt; c.deriveColor(<span class="number">0</span>, <span class="number">1</span>, factor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h2><p>如果一个函数的输出是另一个函数的输入,那么可以把这两个函数组合起来.下面是例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; UnaryOperator&lt;T&gt; <span class="title function_">compose</span><span class="params">(UnaryOperator&lt;T&gt; op1,UnaryOperator&lt;T&gt; op2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t-&gt;op2.apply(op1.apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟和并行操作"><a href="#延迟和并行操作" class="headerlink" title="延迟和并行操作"></a>延迟和并行操作</h2><p>如果一个对象要频繁的进行转换操作,类似Stream,那么最好让这些操作延迟执行.如果一个函数式接口经常被调用,那么应该考虑是否可以使用并行来实现.</p><h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><p>函数式接口通常不允许检查异常,当然,你也可以使用允许检查异常的函数式接口作为参数,如<code>Callable&lt;T&gt;</code>.还有一种方法是使用一个包装器把会抛出检查异常的函数式接口转换成只抛出非检查异常的接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Supplier&lt;T&gt; <span class="title function_">unchecked</span><span class="params">(Callable&lt;T&gt; f)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//把所有的Exception变为运行时异常抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">//所有的Error直接抛出</span></span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lambda和泛型"><a href="#lambda和泛型" class="headerlink" title="lambda和泛型"></a>lambda和泛型</h2><p>如果需要在方法中接受带泛型的函数式接口,需要遵守下面的几条规则:</p><ul><li>如果T是函数参数,但不是函数返回值类型,那么在T前面加<code>? super </code>,类似Scala中的逆变</li><li>如果是返回值类型,但不是函数参数类型,那么在R前面加<code>? extends </code>,类似Scala的协变</li><li>如果T即是参数又是返回值类型,那么不要加任何东西.</li></ul><h2 id="单子操作"><a href="#单子操作" class="headerlink" title="单子操作"></a>单子操作</h2><p>在你设计类型<code>G&lt;T&gt;</code>和函数<code>T-&gt;U</code>的时候,想一下定义一个生成<code>G&lt;U&gt;</code>的方法<code>map</code>是否有意义.如果合适,也可以为函数<code>T-&gt;G&lt;U&gt;</code>提供<code>flatMap</code>方法.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;延迟执行&quot;&gt;&lt;a href=&quot;#延迟执行&quot; class=&quot;headerlink&quot; title=&quot;延迟执行&quot;&gt;&lt;/a&gt;延迟执行&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;所有的lambda表达式都是延迟执行的&lt;/strong&gt;.如果你希望立刻执行,就没必要使用lambda表达式了.延迟执行的原因有很多,例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在另一个线程中运行&lt;/li&gt;
&lt;li&gt;多次运行代码&lt;/li&gt;
&lt;li&gt;在某个算法的正确时间点上运行代码(例如排序算法中的比较操作)&lt;/li&gt;
&lt;li&gt;只有在需要的时候运行代码&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Java Java8" scheme="https://zjjfly.github.io/tags/Java-Java8/"/>
    
  </entry>
  
  <entry>
    <title>使用JMH进行性能测试</title>
    <link href="https://zjjfly.github.io/2017/09/06/2017-9-6-%E4%BD%BF%E7%94%A8JMH%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>https://zjjfly.github.io/2017/09/06/2017-9-6-%E4%BD%BF%E7%94%A8JMH%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</id>
    <published>2017-09-06T01:32:28.000Z</published>
    <updated>2023-05-03T02:16:15.810Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到一个问题，在看&lt;&lt;快学Java8&gt;&gt;的时候，作者让写一段代码比较使用parallel stream和一般的stream的性能差异，书中说直接使用<code>System.currentTimeMillis()</code>记录时间，然后比较耗时长短，结果却发现执行相同的任务(统计&lt;&lt;战争与和平&gt;&gt;这本书中的长单词数量)并行流所花的时间居然比一般的流更长，这显然不符合预期。google之后，在StackOverflow看到一个人说那样测试性能不准确，他推荐使用JMH。改用JMH之后，我最终得到了期望的结果。<br>JMH是一个microbenchmark测试框架，是由OpenJDK的开发人员开发的，所以其结果具有很高的可信性，而且它用起来和JUnit一样的方便。下面是官方的hello world示例：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JMHSample_01_HelloWorld</span> &#123;</span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wellHelloThere</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// this method was intentionally left blank.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(JMHSample_01_HelloWorld.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中的main方法其实是多余的，我们可以通过annotation processor使得测试自动执行，这个之后会介绍。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先，安装IDEA的JMH插件</p><div align="center"><img width="600" height="375" src="https://zjjfly.github.io/images/20170906/jmh-1.jpg"/></div>然后，在项目的gradle配置文件中加上JMH的依赖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testCompile <span class="string">&#x27;org.openjdk.jmh:jmh-core:1.19&#x27;</span></span><br><span class="line">testCompile <span class="string">&#x27;org.openjdk.jmh:jmh-generator-annprocess:1.19&#x27;</span></span><br></pre></td></tr></table></figure><p>注意，<strong>第二个依赖不能省略</strong>，它是JMH实现的自定义注解处理器，用于在IDE中运行JMH的测试。<br>之后，查看IDEA的配置，确保annotation processor是启用的。在Eclipse中需要安装m2e-apt插件并启用。</p><div align="center"><img width="615" height="160" src="https://zjjfly.github.io/images/20170906/jmh-2.jpg"/></div>## 一个简单的测试下面是促使我发现JMH的那个问题的代码，使用JMH重构过。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode(&#123;Mode.AverageTime&#125;)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 5)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 10)</span></span><br><span class="line"><span class="meta">@Fork(10)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BenchMarkTest</span> &#123;</span><br><span class="line">    <span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BenchmarkState</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> List&lt;String&gt; words;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BenchmarkState</span>().getClass().getClassLoader();</span><br><span class="line">            <span class="type">URL</span> <span class="variable">resource</span> <span class="operator">=</span> classLoader.getResource(<span class="string">&quot;War and Peace.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">assert</span> resource != <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> resource.toURI();</span><br><span class="line">                words = Files.lines(Paths.get(uri))</span><br><span class="line">                    .flatMap(Pattern.compile(<span class="string">&quot;[\\P&#123;L&#125;]+&quot;</span>)::splitAsStream)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exer3Steam</span><span class="params">(BenchmarkState state)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        state.words.stream().filter(s -&gt; s.length() &gt;= <span class="number">12</span>).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exer3ParallelSteam</span><span class="params">(BenchmarkState state)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        state.words.parallelStream().filter(s -&gt; s.length() &gt; <span class="number">12</span>).count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，JMH的测试方法是可以有参数的，其中一种就是有<code>@State</code>注解的类的实例。<br>然后把光标移动到类名或方法名上，右击并选择运行。</p><div align="center"><img width="600" height="400" src="https://zjjfly.github.io/images/20170906/jmh-1.gif"/></div>## 配置测试参数JMH有很多参数可以配置，既可以像上面的代码那样通过注解，也可以通过命令行参数进行配置，JMH用于配置的注解都在`org.openjdk.jmh.annotations`这个package中。如果想知道有哪些命令行参数，可以查看类`org.openjdk.jmh.runner.options.CommandLineOptions`，然后在运行配置中加上相应的参数就可以了。<div align="center"><img width="660" height="520" src="https://zjjfly.github.io/images/20170906/jmh-3.jpg"/></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近碰到一个问题，在看&amp;lt;&amp;lt;快学Java8&amp;gt;&amp;gt;的时候，作者让写一段代码比较使用parallel stream和一般的stream的性能差异，书中说直接使用&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;记录时间，然后比较耗时长短，结果却发现执行相同的任务(统计&amp;lt;&amp;lt;战争与和平&amp;gt;&amp;gt;这本书中的长单词数量)并行流所花的时间居然比一般的流更长，这显然不符合预期。google之后，在StackOverflow看到一个人说那样测试性能不准确，他推荐使用JMH。改用JMH之后，我最终得到了期望的结果。&lt;br&gt;JMH是一个microbenchmark测试框架，是由OpenJDK的开发人员开发的，所以其结果具有很高的可信性，而且它用起来和JUnit一样的方便。下面是官方的hello world示例：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java JMH" scheme="https://zjjfly.github.io/tags/Java-JMH/"/>
    
  </entry>
  
  <entry>
    <title>快学Java8 第二章下</title>
    <link href="https://zjjfly.github.io/2017/09/03/2017-9-3-%E5%BF%AB%E5%AD%A6Java8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%8B/"/>
    <id>https://zjjfly.github.io/2017/09/03/2017-9-3-%E5%BF%AB%E5%AD%A6Java8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%8B/</id>
    <published>2017-09-03T01:32:28.000Z</published>
    <updated>2023-05-03T02:30:15.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>如果你想用一种方式计算流的元素的合或者把它们组合成一个结果,你可以使用<code>reduce</code>方法.它接收一个二元函数并不断应用它,第一次的参数是是流的前两个元素,然后是第一次调用的结果和流的第三个元素,依次类推,直到流的最后.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; values = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; sum = values.reduce((x, y) -&gt; x + y)</span><br></pre></td></tr></table></figure><p>这种情况下,<code>reduce</code>计算的是Stream中的数字的和.这个方法返回的是一个<code>Optional</code>,因为Stream可能是空的.你其实可以使用<code>values.reduce(Integer::sum)</code>代替<code>values.reduce((x, y) -&gt; x + y)</code>.</p><span id="more"></span><p>一般来说,如果聚合方法有一个聚合操作<code>op</code>,那么该聚合会产生<code>v0 op v1 op v2 op ...</code>,其中的<code>vi op vi+1</code>表示函数调用<code>op(vi,vi+1)</code>.这个操作应该是满足结合律的,也即是说这个操作和你组合元素的顺序无关,<code>(x op y) op z = x op (y op z)</code>.这样就允许使用并行流进行有效的聚合.<br>在实践中,有很多有用的结合操作,例如和,积,字符串连接,最大值和最小值,并集和交集.减法是一个不满足结合律的操作的例子.例如,<code>(6-3)-2≠6-(3-2)</code>.<br>通常,会有一个标识<code>e</code>使得<code>e op x=x</code>,你可以使用这个元素作为计算的起始.例如,在加法中,0就是这个标识<code>e</code>.然后调用<code>reduce</code>的第二种形式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> values.reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure><p>如果流是空的,这个标识值就会被返回.这样你就不需要处理<code>Optional</code>类了.现在假设你有一个包含多个对象的流,你想要对对象们的某个属性求和,比如流中字符串的总长.你不能使用简单形式的<code>reduce</code>方法,因为它需要的一个函数<code>(T,T)-&gt;T</code>,其中参数类型和返回值类型都必须是一样的,而现在的情况下,这两种类型是不同的,流的元素的类型是字符串,而累积结果的类型是整型.幸好有另一种形式的<code>reduce</code>可以处理这个情况.<br>首先,你要提供一个累加器函数<code>(total,word)-&gt;total+word.length()</code>.这个函数会被重复的调用,形成累加值.但是当并行计算时,会有多个累加值,你需要把它们再累加起来.为了这一点,你需要提供第二个函数.完整代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> words.reduce(<span class="number">0</span>, (s, word) -&gt; s + word.length(), (total, subtotal) -&gt; total + subtotal);</span><br></pre></td></tr></table></figure><p>实践中,你可能不会大量使用<code>ruduce</code>方法,通常,<strong>更简单的方法是映射到一个数字流并使用它的方法来计算总和,最大值和最小值</strong>.在这个例子中,可以调用<code>words.mapToInt(String::length).sum()</code>,它更简单也更高效,因为它不涉及装箱拆箱.</p><h2 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h2><p>当你对一个流进行了处理,你通常想要看到结果而不是吧它们聚合成一个值.你可以调用<code>iterator</code>方法,生成一个旧式的迭代器用来访问元素.或者调用<code>toArray</code>获取流元素组成的一个数组.<br>因为在运行时产生一个泛型的数组是不可能的,<strong>表达式<code>stream.toArray()</code>返回的是一个<code>Object[]</code>数组.如果你想得到一个正确的类型的数组,传入数组的构造器引用</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(<span class="string">&quot;what&quot;</span>, <span class="string">&quot;which&quot;</span>, <span class="string">&quot;where&quot;</span>);</span><br><span class="line">String[] result = words.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>现在假设你想要把结果收集到一个<code>HashSet</code>中,如果集合并行化了,你无法直接把元素放入到单个<code>HashSet</code>中,因为<code>HashSet</code>不是线程安全的.由于这个原因,你也不能使用<code>reduce</code>,每个块都需要一个空的<code>HashSet</code>,但<code>reduce</code>方法只让你提供一个标识值.可以使用<code>collect</code>,它有三个参数:</p><ol><li>一个生成目标对象实例的生产者,比如,一个<code>HashSet</code>的构造器.</li><li>一个把元素添加到目标对象的累加器.例如,<code>add</code>方法.</li><li>一个把两个对象合成一个的组合器,如<code>addAll</code>方法.</li></ol><p>注意,目标对象不一定是集合,也可以是<code>StringBuilder</code>或一个跟踪数量和总和的对象.<br>下面是产生一个<code>HashSet</code>的<code>collect</code>的写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; integers = nums.collect(HashSet::<span class="keyword">new</span>, HashSet&lt;Integer&gt;::add, HashSet::addAll);</span><br></pre></td></tr></table></figure><p>实践中,你不需要这样写,因为有一个便利的<code>Collector</code>接口代替这三个函数,并且有包含了很多常用的收集器的类<code>Collectors</code>.把一个流收集到一个list或set,你只需简单的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result = nums.collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result = nums.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><p>如果你想要控制获得的set类型,可以像下面这样调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; result = nums.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><p>如果想要通过拼接把流中的所有字符串收集起来,你可以调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> StreamFactory.stringStream().collect(Collectors.joining());</span><br></pre></td></tr></table></figure><p>如果你想要在字符串之间加入分隔符,可以把它传入<code>joining</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">delimiter</span> <span class="operator">=</span> StreamFactory.stringStream().collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure><p>如果流中包含的对象不是String类型的,你需要先把它们转换成字符串,像这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">persons</span> <span class="operator">=</span> StreamFactory.objectStream().map(StreamFactory.Person::toString)</span><br><span class="line">                              .collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure><p>如果你想要对流进行聚合求和,平均值,最大值v,最小值,可以使用<code>Collectors</code>中的<code>summarizing</code>方法.这些方法接收一个可以把流中的对象映射到数字的函数,返回一个类型是<code>(Int|Long|Double)SummaryStatistics</code>的对象,它带有获取和,平均值,最大值,最小值的方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span>words.collect(Collectors.summarizingInt(String::length));</span><br><span class="line"><span class="type">double</span> <span class="variable">averageLength</span> <span class="operator">=</span> statistics.getAverage();</span><br><span class="line"><span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> statistics.getMax();</span><br></pre></td></tr></table></figure><p>到此为止,我们已经看到如果聚合和收集流中的值.但你可能只是想要打印它们或把它们放入数据库,你可以使用<code>forEach</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>你传入的这个函数会被应用到流中的每个元素上.在一个并行流中,你需要保证这个函数式可以被并发地执行的.<br>**在一个并行流上,元素可能会被以任意的顺序遍历,如果你想按照流中的属性执行,调用<code>forEachOrdered</code>.**当然,这样你就放弃了并行带来的好处.<br><code>forEach</code>和<code>forEachOrdered</code>方法都是终结操作,调用它们之后,你无法再使用流了.如果你想继续使用流,使用之前提到的<code>peek</code>.</p><h2 id="将结果收集到Map"><a href="#将结果收集到Map" class="headerlink" title="将结果收集到Map"></a>将结果收集到Map</h2><p>假设你有一个<code>Person</code>的流,你想把元素收集到一个Map以便可以使用它们的ID来进行查找.你可以使用<code>Colletors.toMap</code>方法,它有两个函数参数,分别用来生成map的键和值.例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; idToName = people.collect(Collectors.toMap(Person::getId, Person::getName));</span><br></pre></td></tr></table></figure><p>一般情况下,值应该是实际的元素,所以使用<code>Function.identity()</code>作为第二个参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; idToPerson = people.collect(Collectors.toMap(Person::getId, Function.identity()));</span><br></pre></td></tr></table></figure><p>如果多个元素有相同的键,那么收集器会抛出<code>IllegalStateException</code>异常.但你可以通过提供第三个函数参数重写这个行为.这个函数的参数是已有值和新的值,你可以返回它们中的一个或者根据它们另外产生一个值来返回.这里,我们构造一个map,对于系统的支持的所有语言,以其默认语言环境中的名字作为键,以其本地化的名字作为值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Locale&gt; locales = Stream.of(Locale.getAvailableLocales());</span><br><span class="line">Map&lt;String, String&gt; languageNames = locales.collect(Collectors.toMap(</span><br><span class="line">        Locale::getDisplayLanguage,</span><br><span class="line">        l -&gt; l.getDisplayLanguage(l),</span><br><span class="line">        (existingValue, newValue) -&gt; existingValue));</span><br></pre></td></tr></table></figure><p>但是,如果我们希望知道指定国家的所有语言,那么我们需要一个<code>Map&lt;String,Set&lt;String&gt;&gt;</code>对象.首先,我们把每种语言存到单个集中,当发现指定国家的新的语言时,我们就将已有值和新值组合成一个新的集合.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;String&gt;&gt; countryLanguageSets = locales</span><br><span class="line">        .collect(Collectors.toMap(Locale::getDisplayCountry, l -&gt; Collections.singleton(l.getDisplayLanguage()),</span><br><span class="line">                                  (a, b) -&gt; &#123;</span><br><span class="line">                                      HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(a);</span><br><span class="line">                                      set.addAll(b);</span><br><span class="line">                                      <span class="keyword">return</span> set;</span><br><span class="line">                                  &#125;));</span><br></pre></td></tr></table></figure><p>如果你想要的是一个<code>TreeMap</code>,那么你需要提供一个构造器引用作为第四个参数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer, Person&gt; id2Person = people</span><br><span class="line">        .collect(Collectors.toMap(Person::getId, Function.identity(), (o, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        &#125;, TreeMap::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><p>对于上面的三种<code>toMap</code>方法,都有对应的<code>toConcurrentMap</code>方法,用来产生一个并发map.在并行收集过程中应该只使用一个并发的map.当在并行流中使用并发map时,一个共享的map要比合并map更高效,当然,使用共享map无法保证顺序.</p><h2 id="分组和分片"><a href="#分组和分片" class="headerlink" title="分组和分片"></a>分组和分片</h2><p>在之前的章节中,我们看到怎么收集特定国家的所有语言.但是,那个代码很冗长.对有共同特性的值进行分组是是很常见的需求,<code>groupingBy</code>方法就是专门用于分组的.<br>还是对国家语言分组的问题,首先,我们构建这样一个map:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Locale&gt;&gt; country2Locales= locales.collect(Collectors.groupingBy(Locale::getCountry));</span><br></pre></td></tr></table></figure><p>函数<code>Local::getCountry</code>是进行分组的分类函数.现在可以查找指定国家中所有语言,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Locale&gt; swissLocales = country2Locales.get(<span class="string">&quot;CH&quot;</span>);</span><br></pre></td></tr></table></figure><p>当分类函数是一个predicate函数时,流元素会被分为两组:一组是函数会返回true的元素,另一组是返回false的元素.在这种情况下,使用<code>partitionBy</code>方法.例如,把所有语言环境分为两组,一组是使用英语一组使用的是其他语言:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Locale&gt;&gt; englishAndOtherLocales = locales.collect(Collectors.partitioningBy(l -&gt; l.getLanguage().equals(<span class="string">&quot;en&quot;</span>)));</span><br><span class="line">List&lt;Locale&gt; englishLocales = englishAndOtherLocales.get(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><code>groupingBy</code>方法生成的map的值是list,如果你想要使用某种方式处理这些list的时候,你要提供一个downstream的收集器.例如,你想要set而不是list,你可以使用<code>Collectors.toSet</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;Locale&gt;&gt; countryToLocaleSet = locales.collect(groupingBy(Locale::getCountry, toSet()));</span><br></pre></td></tr></table></figure><p>还有若干其他的收集器可以用于分好组的元素的downstream的处理.<br><code>counting</code>产生被收集的元素的个数,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; countryToLocaleCounts = locales.collect(groupingBy(Locale::getCountry, counting()));</span><br></pre></td></tr></table></figure><p><code>summing(Int|Long|Double)</code>接受一个函数参数,应用这个函数到downstream的元素,生成它们的合,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; stateToPopulation = cities.collect(groupingBy(City::getState, summingInt(City::getPopulation)));</span><br></pre></td></tr></table></figure><p><code>maxBy</code>和<code>minBy</code>接收一个比较器并产生downstream元素的最大值和最小值.例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Optional&lt;City&gt;&gt; stateToLargestCity = cities</span><br><span class="line">        .collect(groupingBy(City::getState, maxBy(Comparator.comparingInt(City::getPopulation))));</span><br></pre></td></tr></table></figure><p><code>mapping</code>应用一个函数到downstream,它还需要另一个收集器处理之前的结果.还记得上一个章节中的收集国家的所有语言到一个set的问题吗？<code>mapping</code>方法可以提供一个更加漂亮的解决方案:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Set&lt;String&gt;&gt; countryToLanguages = locales</span><br><span class="line">        .collect(groupingBy(Locale::getDisplayCountry, mapping(Locale::getDisplayLanguage, toSet())));</span><br></pre></td></tr></table></figure><p>如果分组或映射函数的返回值类型是int,long,或double,你可以收集元素到一个统计对象,它在之前章节就出现过.例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, IntSummaryStatistics&gt; stateToCityPopulationSummary = cities</span><br><span class="line">        .collect(groupingBy(City::getState, summarizingInt(City::getPopulation)));</span><br></pre></td></tr></table></figure><p>最后,<code>reducing</code>方法可以对downst的元素应用一个聚合函数.它有三种形式:<code>reducing(binaryOperation)</code>,<code>reducing(identity,binaryOperation)</code>和<code>reducing(identity,mapper,binaryOperation)</code>,这其实和<code>reduce</code>的三种形式是对应的.下面是一个获取每个州的所有城市名以逗号分隔的字符串:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; stateToCityNames = cities.collect(groupingBy(City::getState, reducing(<span class="string">&quot;&quot;</span>, City::getName, (s, s2) -&gt; s</span><br><span class="line">        .length() == <span class="number">0</span> ? s2 : s + <span class="string">&quot;,&quot;</span> + s2)));</span><br></pre></td></tr></table></figure><p>和<code>reduce</code>一样,<code>reducing</code>用的并不多.这个例子中,我们可以更自然的达到目的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stateToCityNames = cities.collect(groupingBy(City::getState, mapping(City::getName, joining(<span class="string">&quot;,&quot;</span>))));</span><br></pre></td></tr></table></figure><p>显然,downstream收集器会产生非常复杂的代码.显然,使用downstream收集器会产生非常复杂的代码.所以,你应该只在处理<code>groupingBy</code>或<code>partitionBy</code>产生的分组的时候使用它们,其他情况,只需要使用诸如<code>map</code>,<code>reduce</code>,<code>count</code>,<code>max</code>或<code>min</code>这些简单的方法即可.</p><h2 id="原生类型流"><a href="#原生类型流" class="headerlink" title="原生类型流"></a>原生类型流</h2><p>目前为止,我们都是把整数收集到一个<code>Stream&lt;Integer&gt;</code>,尽管把每个整形放入包装对象显然是低效的做法.其他原始类型也是一样的.为此,Stream API提供了特化类型<code>IntStream</code>,<code>LongStream</code>和<code>DoubleStream</code>,它们直接存储原始类型值,不需要包装.下面是对应关系:</p><ul><li>存放short、char、byte、int和boolean类型的值,使用<code>IntStream</code></li><li>存放float和double类型的值,使用<code>DoubleStream</code>.</li><li>存放long类型的值,使用<code>LongStream</code>.</li></ul><p>要创建一个<code>IntStream</code>,可以调用<code>IntStream.of</code>和<code>Arrays.stream</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">stream = Arrays.stream(values);</span><br></pre></td></tr></table></figure><p>和对象流一样,<code>IntStream</code>和<code>LongStream</code>提供了静态方法<code>range</code>和<code>rangeClosed</code>来生成步数为1的数列.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">zeroToNinetyNine</span> <span class="operator">=</span> IntStream.range(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">zeroToHundred</span> <span class="operator">=</span> IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><code>CharSequnces</code>有两个方法<code>codePoints</code>和<code>chars</code>分别生成Unicode字符的<code>IntStream</code>和UTF-16编码单元的<code>IntStream</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> <span class="string">&quot;\uD835\uDD46 is the set of octonions&quot;</span>;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">codes</span> <span class="operator">=</span> sentence.codePoints();</span><br></pre></td></tr></table></figure><p>当你有一个对象流,你可以使用<code>mapToInt</code>,<code>mapToDouble</code>,<code>mapToLong</code>方法把它转换成原生类型流.例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = StreamFactory.stringStream();</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">lengths</span> <span class="operator">=</span> words.mapToInt(String::length);</span><br></pre></td></tr></table></figure><p>使用<code>boxed</code>方法把原生类型流转换为对象流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integers = IntStream.range(<span class="number">0</span>, <span class="number">100</span>).boxed();</span><br></pre></td></tr></table></figure><p>一般而言,原生类型流的方法和对象流的方法是类型的,下面是原生类型流和对象流最显著的一些区别:</p><ul><li>原生类型流的<code>toArray</code>返回原生类型数组,而对象流的<code>toArray</code>方法返回的是对象数组</li><li>原生类型流的生成可选结果的方法返回的是<code>OptionalInt</code>、<code>OptionalLong</code>或<code>OptionalDouble</code>.这些类和<code>Optional</code>类相似,但是它们有<code>getAsInt</code>、<code>getAsLong</code>和<code>getAsDouble</code>来代替<code>get</code>方法.</li><li>原生类型流有<code>sum</code>,<code>average</code>,<code>max</code>和<code>min</code>方法,对象流没有</li><li><code>summaryStatistics</code>方法生成一个类型是<code>IntSummaryStatistics</code>、<code>LongSummaryStatistics</code>和<code>DoubleSummaryStatistics</code>的对象,通过它们可以获取流的总和,平均值,最大值和最小值.</li></ul><p><code>Random</code>类的<code>ints</code>,<code>longs</code>和<code>doubles</code>方法返回随机数的原生类型流,但要注意,这些流是无限流.</p><h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><p>流使对大量运算并行化非常容易.这一过程基本是自动的,但你也需要遵守一些规则.首先,你要有一个并行流.除了<code>Collection.parallelStream</code>方法,流操作生成的都是顺序流.<code>parellel</code>方法可以把任意顺序流转换成并行流.例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; parallelIntegers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>).parallelStream();</span><br><span class="line">Stream&lt;String&gt; parallelWords = Stream.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>).parallel();</span><br></pre></td></tr></table></figure><p>只要流是处于并行模式,当执行终结方法的时候,所有的中间流操作都会被并行化.<br>并行化的目的,是希望能得到和顺序执行一样的结果,所以操作必须是无状态和顺序无关,这很重要.<br>下面有一个反例,加上你要计算字符串流中短单词的个数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] shortWords = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; words = Files.lines(Paths.get(<span class="string">&quot;gradlew&quot;</span>))</span><br><span class="line">                                 .flatMap(s -&gt; Arrays.stream(s.split(<span class="string">&quot;[\\P&#123;L&#125;]+&quot;</span>)))) &#123;</span><br><span class="line">    words.parallel().forEach(s -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; <span class="number">12</span>) &#123;</span><br><span class="line">            shortWords[s.length()]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(shortWords));</span><br></pre></td></tr></table></figure><p>这是非常糟糕的代码.传递给forEach的函数会在多个线程中并发执行,来更新一个共享的数组,这是典型的竞态条件如果你将这段代码多运行几次,很可能每次都会得到不同的结果,而且没有一个是对的.<br><strong>你需要确保传递给并行流操作的函数式线程安全的</strong>.在我们这个例子中,你可以使用一个<code>AtomicInteger</code>的数组作为计数器,或者使用Stream API提供的方法,对字符串按长度分组再计数.<br>默认情况下,从有序集合(数组或列表),范围值,生成器以及迭代器,或者<code>Stream.sorted</code>所产生的流,都是有序的.对这些流操作的结果也是按照顺序累计的,是完全可预测的.如果你只需相同的操作两次,得到的结果也会是相同的.<br>顺序并不会妨碍并行.例如,当计算<code>stream.map(fun)</code>时,流会分为n块,每一块都会被并行处理,然后在按照顺序将结果组合起来.<br>当不考虑顺序时,某些操作可能会更加高效地并行化.<strong>通过调用<code>stream.unordered</code>方法,你可以表明你不关心顺序</strong>,<code>stream.distinct</code>就是一个可以从中受益的操作.对于有序流,<code>distinct</code>方法会保留所有的相等元素的第一个,这样会阻碍并行,因为处理某块流的线程只有在之前的元素块处理完之后,才知道应该丢弃哪些元素.如果允许保留任意的唯一元素,所有的块都可以并行处理(使用一个共享的set)<br><strong>你还可以通过放弃有序来加快<code>limit</code>方法的速度</strong>.如果你想要一个流中任意n个元素,可以这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; sample = stream.parallel().unordered().limit(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>之前说过,合并map的开销很大,所以,<code>Collectors.groupingByConcurrent</code>使用一个共享的并发map.显然,要从并行计算中获益,map中的值的顺序将无法保证与流中的顺序一致.即使是对于一个有序的流,该收集器也具有无序的天性,因此你<strong>不需要</strong>标记这个流是无序的.但是,你还是需要将流标记为并行模式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;String, List&lt;City&gt;&gt; re = cities.parallel().collect(Collectors.groupingByConcurrent(City::getState));</span><br></pre></td></tr></table></figure><p>注意,<strong>当你执行一个流操作的时候,你并不会修改流底层的集合(即使这个操作是线程安全的)</strong>.准确一点说,由于中间流操作是延迟执行的,所以在终结操作执行的之前改变集合是可能的.例如,下面的代码是正确的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(<span class="string">&quot;BEGIN&quot;</span>,<span class="string">&quot;RUNNING&quot;</span>);</span><br><span class="line">words.add(<span class="string">&quot;END&quot;</span>);</span><br><span class="line"><span class="keyword">assert</span> <span class="number">3</span> == words.distinct().count();</span><br></pre></td></tr></table></figure><p>但下面的代码是不正确的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">words = wordList.stream();</span><br><span class="line">words.forEach(s -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">7</span>)</span><br><span class="line">        wordList.remove(s);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>在本章中,已经看了很多参数为函数的方法.例如<code>Stream.filter</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure><p>查看javadoc,发现<code>Predicate</code>是一个函数式接口,只包含一个返回boolean的非默认方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br></pre></td></tr></table></figure><p>在实际开发中,一般会传递lambda或者方法引用到<code>filter</code>方法.所以这个方法的名字并不重要,重要的是返回的是boolean值.你在看文档的时候,只要记住<code>Predicate</code>是一个返回boolean值的函数就行.<br>下面的图列举了作为<code>Stream</code>和<code>Collectors</code>方法参数的函数式接口:</p><div align="center"><img width="660" height="520" src="https://zjjfly.github.io/images/20170903/java8-2-1.png"/></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;聚合&quot;&gt;&lt;a href=&quot;#聚合&quot; class=&quot;headerlink&quot; title=&quot;聚合&quot;&gt;&lt;/a&gt;聚合&lt;/h2&gt;&lt;p&gt;如果你想用一种方式计算流的元素的合或者把它们组合成一个结果,你可以使用&lt;code&gt;reduce&lt;/code&gt;方法.它接收一个二元函数并不断应用它,第一次的参数是是流的前两个元素,然后是第一次调用的结果和流的第三个元素,依次类推,直到流的最后.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Stream&amp;lt;Integer&amp;gt; values = Stream.of(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Optional&amp;lt;Integer&amp;gt; sum = values.reduce((x, y) -&amp;gt; x + y)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这种情况下,&lt;code&gt;reduce&lt;/code&gt;计算的是Stream中的数字的和.这个方法返回的是一个&lt;code&gt;Optional&lt;/code&gt;,因为Stream可能是空的.你其实可以使用&lt;code&gt;values.reduce(Integer::sum)&lt;/code&gt;代替&lt;code&gt;values.reduce((x, y) -&amp;gt; x + y)&lt;/code&gt;.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java Java8" scheme="https://zjjfly.github.io/tags/Java-Java8/"/>
    
  </entry>
  
  <entry>
    <title>快学Java8 第二章上</title>
    <link href="https://zjjfly.github.io/2017/09/03/2017-9-3-%E5%BF%AB%E5%AD%A6Java8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%8A/"/>
    <id>https://zjjfly.github.io/2017/09/03/2017-9-3-%E5%BF%AB%E5%AD%A6Java8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%8A/</id>
    <published>2017-09-03T01:32:28.000Z</published>
    <updated>2023-05-03T02:28:18.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从迭代到Stream操作"><a href="#从迭代到Stream操作" class="headerlink" title="从迭代到Stream操作"></a>从迭代到Stream操作</h2><p>以前，我们要处理一个集合，一般都是迭代它的元素并对每个元素做一些操作。例如，你想计算一本书中长词的数量，首先，把书的内容放入的一行为单位放入list：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Files.readAllBytes(</span><br><span class="line">        Paths.get(<span class="string">&quot;alice.txt&quot;</span>)), StandardCharse.UTF_8);</span><br><span class="line">List&lt;String&gt; words = Arrays.asList(content.split(<span class="string">&quot;[\\P&#123;L&#125;]+&quot;</span>));</span><br></pre></td></tr></table></figure><p>然后开始迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">    <span class="keyword">if</span> (word.length()&gt;<span class="number">12</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有啥问题吗？基本没有，除了这个代码<strong>很难并行</strong>。这就是Java8引入Stream的原因。同样的操作，Java8可以这么写：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> words.stream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure><p><code>stream</code>方法生成一个<code>words</code>列表的Stream，<code>filter</code>方法返回另一个只包含长度大于12的单词的Stream，<code>count</code>方法把Stream归并为一个结果：Stream的元素个数。<br>Stream在外表是和集合很相似，它允许你变换和抽取数据。但它们其实是非常不同的：</p><ul><li><strong>Stream并不存储它的元素</strong>,它们可能会存储在底层的集合中或者根据需要生成。</li><li>Stream并不改变它们的数据源，相反，<strong>它们返回持有结果的新的Stream</strong>。</li><li><strong>Stream操作可能是延迟执行的</strong>。这意味着它们会等到需要结果的时候才会执行。例如，如果你只需要前五个长单词，那么<code>filter</code>方法会在第五次匹配之后停止过滤。因此，你甚至可以拥有无限的流。</li></ul><p>很多人都觉得Stream表达式比循环更易读，此外，它们更容易并行。下面是如何并行地统计长词：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> count=words.parallelStream().filter(w-&gt;w.length()&gt;<span class="number">12</span>).count();</span><br></pre></td></tr></table></figure><p>只需要把<code>stream</code>方法改成<code>parallelStream</code>方法，就可以让StreamAPI并行地执行过滤和计数操作。<br>Stream遵从“做什么，而不是怎么做”这个原则。在上面的例子中，我们描述了需要做什么：获取长单词并统计。我们并不指明按什么顺序或在哪个线程中做。相反，循环一开始就指定了计算如何进行，因此失去了任何优化的机会。<br>当你使用Stream时，你会通过三个步骤来建立一个操作流水线：</p><ol><li>创建一个Stream</li><li>在一个或多个步骤中，指定将初始的Stream转换成另一个Stream的中间操作</li><li>使用一个终止操作产生一个结果。这个操作强制它之前的延迟操作立即执行，在这之后，Stream不能再被使用了。</li></ol><p>在我们例子中，Stream由<code>stream</code>或<code>parallelStream</code>方法产生。<code>filter</code>方法对它进行转换，<code>count</code>是终结操作。<br><strong>Stream操作不会按照元素的调用顺序执行</strong>。在上面的例子中，只有在调用<code>count</code>的时候才会执行Stream操作。当<code>count</code>需要第一个元素的时候，<code>filter</code>方法开始请求元素，直到它找到一个长度大于12的元素。</p><h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><p>我们已经知道可以使用Java8加入<code>Collection</code>接口的<code>stream</code>方法把任何集合转变成Stream。如果你想要把数组转成Stream，可以使用静态方法<code>Stream.of</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(content.split(<span class="string">&quot;[\\P&#123;L&#125;]+&quot;</span>));</span><br></pre></td></tr></table></figure><p><code>of</code>有一个可变的参数，所以你可以用任意数量的参数来构造Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; songs = Stream.of(<span class="string">&quot;gently&quot;</span>, <span class="string">&quot;down&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;stream&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用<code>Arrays.stream(array,from,to)</code>来使数组的一部分变成Stream。<br>要创建一个空的Stream，可以使用<code>Stream.empty</code>这个静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; silence = Stream.empty();</span><br></pre></td></tr></table></figure><p><code>Stream</code>接口有两个静态方法用来创建无限Stream。<code>generate</code>方法接受一个无参数的函数(或者，技术上说，一个<code>Supplier&lt;T&gt;接口的对象</code>)。当你需要一个Stream值时，这个函数会被调用来生成一个值。你可以使用下面的代码得到一个含有常量的Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; echos = Stream.generate(() -&gt; <span class="string">&quot;Echo&quot;</span>);</span><br></pre></td></tr></table></figure><p>或者一个随机数的Stream:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Double&gt; randoms = Stream.generate(Math::random);</span><br></pre></td></tr></table></figure><p>而要产生像”0 1 2 3 …”这样的序列，使用<code>iterate</code>方法。它接受一个种子(seed)值和一个函数(技术上来说，一个<code>UnaryOperation&lt;T&gt;</code>对象)，并且会对之前的值重复的应用该函数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO, bigInteger -&gt; bigInteger.add(BigInteger.ONE));</span><br></pre></td></tr></table></figure><p>序列的第一个值是seed，第二个值是<code>f(seed)</code>，第三个是<code>f(f(seed))</code>，以此类推。<br>Java的API中加入了不少生成Stream的方法。例如，<code>Pattern</code>类现在有一个方法<code>splitAsStream</code>可以用一个正则表达式切分<code>CharSequence</code>对象，返回一个Stream。这是例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; splitStream = Pattern.compile(<span class="string">&quot;[\\P&#123;L&#125;]+&quot;</span>).splitAsStream(content);</span><br></pre></td></tr></table></figure><p>静态方法<code>Files.lines</code>返回包含文件所有的行的Stream。<code>Stream</code>接口有一个<code>AutoCloseable</code>父接口。当<code>Stream</code>的<code>close</code>方法被调用的时候，底层的文件也会被关闭。为了确保<code>close</code>会被调用，可以使用Java7的try-with-resource声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream&lt;String&gt; lines=Files.lines(Paths.get(<span class="string">&quot;gradlew&quot;</span>))) &#123;</span><br><span class="line">    System.out.println(lines.count());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filter-map和flatMap方法"><a href="#filter-map和flatMap方法" class="headerlink" title="filter,map和flatMap方法"></a>filter,map和flatMap方法</h2><p>流转换是从一个流读取数据，然后把转换后的数据放入另一个流中。我们已经看到<code>filter</code>这个转换方法，它会生成一个新的流，其中包含了满足特定条件的所有元素。现在，我们要讲一个字符串流转换到另一个只包含长单词的流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; wordsList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; words = wordsList.stream();</span><br><span class="line">Stream&lt;String&gt; longWords = words.filter(s -&gt; s.length() &gt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p><code>filter</code>的参数是一个<code>Predicate&lt;T&gt;</code>，这是一个从<code>T</code>到<code>boolean</code>的函数。<br>我们通常会想对一个流中的值进行某种形式的转换。可以使用<code>map</code>方法，传递给它一个执行转换的函数。例如，你可以用下面的代码把所以的单词转换为小写形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; lowcaseWords = words.map(String::toLowerCase);</span><br></pre></td></tr></table></figure><p>这里我们使用的是一个方法引用。但通常,我们会使用一个lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; firstChars = words.map(s -&gt; s.charAt(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>当你使用<code>map</code>的时候，会对每一个元素应用函数，并将返回值收集到一个新的流中。现在假设返回的不是一个值，而是包含多个值的流，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">characterStream</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    List&lt;Character&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        result.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，<code>characterStream(&quot;boat&quot;)</code>返回的是流<code>stream[&#39;b&#39;,&#39;o&#39;,&#39;a&#39;,&#39;t&#39;]</code>。假设你这个方法映射到字符串流上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Stream&lt;Character&gt;&gt; result = words.map(TransformMethod::characterStream);</span><br></pre></td></tr></table></figure><p>你会得到一个元素是流的流。要将它展开为一个只包含字符的流，你需要使用<code>flatMap</code>方法而不是<code>map</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; characterStream = words.flatMap(TransformMethod::characterStream);</span><br></pre></td></tr></table></figure><h2 id="抽取子流和组合流"><a href="#抽取子流和组合流" class="headerlink" title="抽取子流和组合流"></a>抽取子流和组合流</h2><p>调用<code>Stream</code>的<code>limit(n)</code>方法，返回含有n个元素的新的流(或者返回原来的流如果原来流的大小比n小)。这个方法对于把无限的流切成一定大小是很有用的。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Double&gt; randoms = Stream.generate(Math::random).limit(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>Stream的<code>skip(n)</code>方法正好相反，它会丢弃前n个元素。在我们之前的读书的例子中，由于<code>split</code>方法的作用方式，产生的第一个元素是一个空字符串(其实我没觉得第一个元素会是空格…)，我们可以使用<code>skip</code>方法来略过这个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(<span class="string">&quot;Hello World&quot;</span>.split(<span class="string">&quot;[\\P&#123;L&#125;]+&quot;</span>)).skip(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>你可以用<code>Stream</code>类的静态方法<code>concat</code>把两个流连接起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; combined = Stream.concat(characterStream(<span class="string">&quot;Hello&quot;</span>), characterStream(<span class="string">&quot;World&quot;</span>));</span><br></pre></td></tr></table></figure><p>当然，<strong>第一个流的长度不能是无限的</strong>,否则第二个流就永远没有机会被使用。<br>还有一个<code>peek</code>方法，生成的流中的元素和原来的流完全一样，但是<strong>每次在其中取一个元素都会调用一个函数</strong>，这个方法对于debug是很方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] powers = Stream.iterate(<span class="number">1</span>, integer -&gt; integer * <span class="number">2</span>).peek(e -&gt; System.out.println(<span class="string">&quot;Fetching:&quot;</span> + e)).limit(<span class="number">20</span>).toArray();</span><br></pre></td></tr></table></figure><p>当某个元素真正被访问了，才会打印出来一个消息。这样的方法可以验证对流的处理是lazy的。</p><h2 id="有状态的转换"><a href="#有状态的转换" class="headerlink" title="有状态的转换"></a>有状态的转换</h2><p>之前说的那些转换方法都是无状态的，当你从一个已过滤的或已映射过的流中获取一个元素的时候，它的结果并不依赖于之前获取的元素。除此之前，也有一些有状态的转换方法。例如<code>distinct</code>方法，它根据原来的流中的元素返回一个具有相同属性，剔除了重复的元素的流。这个流显然是必须记住已经读取的元素的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; uniqueWords = Stream.of(<span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;merrily&quot;</span>, <span class="string">&quot;gently&quot;</span>).distinct();</span><br></pre></td></tr></table></figure><p><code>sorted</code>方法必须遍历整个流，并在产生任何元素之前就对其进行排序，毕竟，最小的元素可以位于最后。显然，你不能对一个无限的流进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; longestFirst=words.sorted(Comparator.comparingInt(String::length).reversed());</span><br></pre></td></tr></table></figure><p>当然，你不需要使用流也可以对集合进行排序，<strong>当排序只是多个流操作之一时，<code>sorted</code>方法是很有用的</strong>。<br>注意，<code>Collection.sort</code>是在原来的集合中进行排序，而<code>sorted</code>方法会返回一个已经排好序的新的流。</p><h2 id="简单的聚合方法"><a href="#简单的聚合方法" class="headerlink" title="简单的聚合方法"></a>简单的聚合方法</h2><p>我们已经了解了如何创建和转换流，现在介绍最重要的一点：如何从流获取答案。这一节中涉及的方法统称为聚合方法。它们把流聚合成一个值以便使用。聚合方法是终结操作。<br>之前我们已经看到过一个简单的聚合方法<code>count</code>，他返回流的元素数量。其他的一些简单的聚合方法有<code>min</code>和<code>max</code>，但需要注意的是，<strong>它们返回的是一个<code>Optional&lt;T&gt;</code><strong>，它可能会封装了返回值，也可能表示没有返回值(如果流是空的)。在Java8之前，这种情况通常会返回null，但这可能会导致空指针异常。</strong>Java8中，<code>Optional</code>类型是一种更好的表明没有返回值的方式</strong>。下一章中会详细讨论<code>Optional</code>类型。下面的例子演示了如何从流中获取最大值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; largest = sortedWords.max(String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><p><code>finFirst</code>方法返回集合中的第一个值，返回的也是<code>Optional&lt;T&gt;</code>。<strong>它通常和<code>filter</code>方法结合使用</strong>。比如，返回第一个以Q开头的单词：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; startWithQ = words.filter(s -&gt; s.startsWith(<span class="string">&quot;Q&quot;</span>)).findFirst();</span><br></pre></td></tr></table></figure><p>如果你不在乎是否是第一个，只想要任意的匹配项，可以使用<code>findAny</code>，<strong>它在你并行地处理流的时候非常高效</strong>，因为在任意片段中找到了第一个匹配项就会结束整个计算了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; startWithQ = words.parallel().filter(s -&gt; s.startsWith(<span class="string">&quot;Q&quot;</span>)).findAny();</span><br></pre></td></tr></table></figure><p>如果你只想知道流中是否有匹配的元素，使用<code>anyMatch</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">aWordStartsWithQ</span> <span class="operator">=</span> words.parallel().anyMatch(s -&gt; s.startsWith(<span class="string">&quot;Q&quot;</span>));</span><br></pre></td></tr></table></figure><p>还有两个方法<code>allMatch</code>和<code>noneMatch</code>，它们分别在所有元素或没有元素匹配的时候返回true。<strong>虽然它们都会检查整个流，但你还是可以并行执行来提高效率。</strong></p><h2 id="Optional类型"><a href="#Optional类型" class="headerlink" title="Optional类型"></a>Optional类型</h2><p>一个<code>Optional&lt;T&gt;</code>对象是一个T类型对象的封装，或者表示没有任何对象。Java8引入它是想把它作为一个相比T类型引用更安全的选择。但是，<strong>你只有正确的使用它，它才是更安全的</strong>。<br>它的<code>get</code>方法会返回封装的元素如果存在的话，否则会抛出异常<code>NoSuchElementException</code>。因此，代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; optionalValue = ...; </span><br><span class="line">optionalValue.get().someMethod()</span><br></pre></td></tr></table></figure><p>并不比下面的代码更安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> ...; </span><br><span class="line">value.someMethod();</span><br></pre></td></tr></table></figure><p>在前面的章节中，我们看到<code>isPresent</code>方法会反映<code>Optional&lt;T&gt;</code>对象中是否有值，但是，代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (optionalValue.isPresent()) optionalValue.get().someMethod();</span><br></pre></td></tr></table></figure><p>并不比下面的代码更简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value != <span class="literal">null</span>) value.someMethod();</span><br></pre></td></tr></table></figure><h3 id="使用Optional值"><a href="#使用Optional值" class="headerlink" title="使用Optional值"></a>使用Optional值</h3><p><strong>高效的使用Optional的关键是，使用一个或者接收正确的值或者产生替代值的方法。</strong><br>方法<code>ifPresent</code>接收一个函数，如果存在可选值，那么它会被传递给函数，如果没有，什么都不会发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optionalValue.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p><code>ifPresent</code>不会返回值，<strong>如果你希望对结果进行处理，用<code>map</code>方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Boolean&gt; added = optionalValue.map(results::add);</span><br></pre></td></tr></table></figure><p><code>added</code>可能有三种值：封装着true或false的<code>Optional</code>对象如果<code>optionalValue</code>中有值的话，否则的话是一个空的<code>Optional</code>对象。<br>这个<code>map</code>方法和流的<code>map</code>方法是类似的，你可以把<code>Optional</code>看成是一个大小是0或1的流,返回的流的大小也是0或1，后一种情况会应用<code>map</code>接收的函数。<br>我们已经知道当一个可选值存在时应该如何优雅的对它进行处理。另一个使用可选值的策略是当没有值存在时产生一个替代值。通常，当没有匹配项时，你会想要使用一个默认值，例如空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> optionalString.orElse(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>你也可以调用函数来计算默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result=optionalString.orElseGet(() -&gt; System.getProperty(<span class="string">&quot;user.dir&quot;</span>))</span><br></pre></td></tr></table></figure><p>或者，你想在没有值的时候抛出其他的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">error</span> <span class="operator">=</span> optionalString.orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h3 id="生成Optional值"><a href="#生成Optional值" class="headerlink" title="生成Optional值"></a>生成Optional值</h3><p>如果你想编写一个产生<code>Optional</code>对象的方法，有一些静态方法可以选择。例如，<code>Optional.of</code>和<code>Optional.empty</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Double&gt; <span class="title function_">inverse</span><span class="params">(Double x)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x==<span class="number">0</span>?Optional.empty():Optional.of(<span class="number">1</span>/x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ofNullable</code>方法计划作为null值和可选值之间的桥梁。<code>Optional.ofNullable(obj)</code>在obj不是null的时候返回<code>Optional.of(obj)</code>，否则返回<code>Optional.empty()</code>。</p><h3 id="使用flatMap组合可选值的函数"><a href="#使用flatMap组合可选值的函数" class="headerlink" title="使用flatMap组合可选值的函数"></a>使用flatMap组合可选值的函数</h3><p>假设你一个方法<code>f</code>可以生成<code>Optional&lt;T&gt;</code>，T类型又有一个方法<code>g</code>可以生成<code>Optional&lt;U&gt;</code>。如果它们是一般的方法，你可以用<code>s.f().g()</code>把它们组合起来。但是，这样的组合在这里行不通，因为<code>s.f()</code>的类型是<code>Optional&lt;T&gt;</code>,而不是T。但你可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;U&gt; = s.f().flatMap(T::g);</span><br></pre></td></tr></table></figure><p>如果<code>s.f()</code>存在值，那么会继续调用<code>g</code>，否则，会返回一个空的<code>Optional&lt;U&gt;</code>。<br>显然，如果你有更多的返回<code>Optional</code>值的方法或lambda表达式，你可以重复这个步骤，通过不断调用<code>flatMap</code>，创建一个调用的流水线，只有当其中的每部分都成功时，整个处理才算是成功了。<br>以上面的安全的求倒数的方法为例，我们再写一个安全的求平方根的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Double&gt; <span class="title function_">squre</span><span class="params">(Double x)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==<span class="number">0</span>?Optional.empty():Optional.of(Math.sqrt(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么你可以这样计算倒数的平方根：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Double&gt; result = inverse(<span class="number">4.0</span>).flatMap(OptionalType::squre);</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Double&gt; result = Optional.of(<span class="number">4.0</span>).flatMap(OptionalType::inverse).flatMap(OptionalType::inverse);</span><br></pre></td></tr></table></figure><p>不管是<code>inverse</code>还是<code>square</code>方法返回<code>Optional.empty()</code>，结果都为空。<br><strong>和<code>map</code>一样，其实<code>flatMap</code>和流的<code>flatMap</code>的方法很类似，如果你把<code>Optional</code>看做一个大小是0或1的流。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;从迭代到Stream操作&quot;&gt;&lt;a href=&quot;#从迭代到Stream操作&quot; class=&quot;headerlink&quot; title=&quot;从迭代到Stream操作&quot;&gt;&lt;/a&gt;从迭代到Stream操作&lt;/h2&gt;&lt;p&gt;以前，我们要处理一个集合，一般都是迭代它的元素并对每个元素做一些操作。例如，你想计算一本书中长词的数量，首先，把书的内容放入的一行为单位放入list：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;String&lt;/span&gt;(Files.readAllBytes(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Paths.get(&lt;span class=&quot;string&quot;&gt;&amp;quot;alice.txt&amp;quot;&lt;/span&gt;)), StandardCharse.UTF_8);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; words = Arrays.asList(content.split(&lt;span class=&quot;string&quot;&gt;&amp;quot;[&#92;&#92;P&amp;#123;L&amp;#125;]+&amp;quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后开始迭代：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; count=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (String word : words) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (word.length()&amp;gt;&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这有啥问题吗？基本没有，除了这个代码&lt;strong&gt;很难并行&lt;/strong&gt;。这就是Java8引入Stream的原因。同样的操作，Java8可以这么写：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java Java8" scheme="https://zjjfly.github.io/tags/Java-Java8/"/>
    
  </entry>
  
  <entry>
    <title>快学Java8(第一章)</title>
    <link href="https://zjjfly.github.io/2017/07/30/2017-7-30-%E5%BF%AB%E5%AD%A6Java8-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://zjjfly.github.io/2017/07/30/2017-7-30-%E5%BF%AB%E5%AD%A6Java8-%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2017-07-30T01:32:28.000Z</published>
    <updated>2023-05-03T02:27:37.761Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始看&lt;&lt;写给大忙人看到Java SE 8&gt;&gt;,由于和我看过的《快学Scala》是一个系列的，所以姑且叫它《快学Java8》。这一篇是第一章的看书笔记，以后每个章节也都会有一篇笔记。</p><h2 id="为什么要引入Lambda表达式"><a href="#为什么要引入Lambda表达式" class="headerlink" title="为什么要引入Lambda表达式"></a>为什么要引入Lambda表达式</h2><p>Java引入的最重要的特性是lambda表达式。lambda表达式实际上是一段可以传递的代码。在Java8之前，由于Java的设计问题，要传递代码必须构造一个类的对象，它的某个方法包含了需要的代码。看个例子：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt;&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2v)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> Integer.compare(o1.length(),o2.length());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] strings = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bcd&quot;</span>, <span class="string">&quot;ef&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(strings, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>());</span><br></pre></td></tr></table></figure><p>而其他一些语言可以直接传递代码块。一开始Java的设计者不想要加入这一特性，但随着函数式编程越来越流行，终于在Java8中，我们可以使用lambda来传递代码了。</p><h2 id="lambda的语法"><a href="#lambda的语法" class="headerlink" title="lambda的语法"></a>lambda的语法</h2><p>lambda由参数，箭头(-&gt;),表达式组成。我们用lambda重写上面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bcd&quot;</span>, <span class="string">&quot;ef&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(strings,(String o1,String o2) -&gt; Integer.compare(o1.length(),o2.length()));</span><br></pre></td></tr></table></figure><p>如果代码不止不止一行，那么可以使用花括号把多行代码包裹起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings,(String o1,String o2) -&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (o1.length()&gt;o2.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (o1.length()&lt;o2.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果lambda表达式没有参数，可以提供一对空的括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果labmda表达式的参数类型是可以被推导出来的，可以省略它们的类型，实际上，<strong>大多数情况</strong>就是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp=(first,second)-&gt;Integer.compare(first.length(),second.length());</span><br></pre></td></tr></table></figure><p>这里就可以推导出<code>first</code>,<code>second</code>的类型是字符串，因为<code>comp</code>被声明为一个字符串比较器。<br>如果某个lambda表达式只有一个参数，并且它的参数类型是可以被推导出来的，那么我们可以省略括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventHandler&lt;ActionEvent&gt; listener=event -&gt; System.out.println(<span class="string">&quot;Click&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>不需要</strong>为lambda表达式声明返回值类型，它会从上下文被推导出。</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Java中很多已有的接口都是用来封装代码块的，例如<code>Runnable</code>,<code>Comparator</code>。lambda表达式与这些接口是兼容的。<br>那些只包含一个抽象方法的接口，我们可以使用lambda来创建该接口的对象，这种接口被称为函数式接口。<br>你可能会奇怪为什么只能有一个抽象方法，难道接口的方法不都是抽象的吗？事实上，<strong>接口经常会重新声明Object类中的方法，为了关联Javadoc的注释</strong>，<code>Comparator</code>就是例子。而且，Java8的接口也可以声明非抽象方法。<br>实际上，lambda唯一做的事情就是函数式接口的转换。在其他语言中，函数可能就是一致类型，但在Java中，<strong>lambda表达式实际还是接口的对象</strong>。<br>在<code>java.util.funtion</code>包中，定义了很多非常通用的函数式接口(我们会在之后两章提到)。其中，有一个<code>BiFuntion&lt;T,U,R&gt;</code>，描述了参数类型是T和U并且返回值类型是R的函数。我们可以把上面的字符串比较的lambda表达式保存在这个类型的变量中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;String ,String ,Integer&gt; comp=(first,second)-&gt;Integer.compare(first.length(),second.length());</span><br></pre></td></tr></table></figure><p>但这个对象对排序没有什么用，因为不存在接收<code>BiFuntion</code>作为参数的<code>Arrays.sort</code>方法。这和其他函数式语言是很不同的。<br>记住，<strong>任意一个lambda表达式都可以等价转换成现在所使用的API中对应的函数式接口</strong>。<br>你可以在任何函数式接口上标注<code>@FunctionalInterface</code>注解。这样做有两个好处：</p><ul><li>编译器会检查标注该注解的实体，检查它是否是只包含一个抽象方法的接口。</li><li>在Javadoc页面会包含一条声明，说明这个接口是函数式接口。</li></ul><p>这个注解不是强制要求的，但是为了规范代码，<strong>对于函数式接口，都要加上这个注解。</strong><br>最后，当一个lambda表达式被转换成一个函数式接口实例的时候，要注意处理检查时异常。如果lambda表达式可能抛出检查时异常，那么该异常需要在目标接口的抽象方法中进行声明。一下代码会产生一个错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runnable sleep=() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Zzz&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Runnable.run</code>方法是不能抛出异常的，所以这个赋值是不合法的。解决的方法有两个：</p><ul><li>在lambda表达式中捕获异常</li><li>把lambda表达式赋值给一个其抽象方法可以抛出异常的接口。</li></ul><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>有时候，我们想要传递的代码已经有实现的方法了。例如，你只想打印数组中的元素，按照之前的做法，代码可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).forEach(i-&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><p>但其实我们可以直接把方法传递给<code>forEach</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>其中，<code>System.out::println</code>是一个方法引用，等同于<code>x-&gt;System.out.println(x)</code>。在举一个例子，假如你想不区分大小写地对字符串进行排序，那么可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;bcd&quot;</span>,<span class="string">&quot;ef&quot;</span>&#125;,String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><p>正如实例代码所示，<code>::</code>操作符把实例或者类的名字和方法名分隔开。下面是三种主要的用法：</p><ul><li>对象::实例方法</li><li>类::静态方法</li><li>类::实例方法</li></ul><p>前两种情况，方法引用等同于接收参数并调用方法的lambda表达式，<code>System.out::println</code>等同于<code>x-&gt;System.out.println(x)</code>，<code>Math::pow</code>等同于<code>(x,y)-&gt;Math.pow(x,y)</code>。<br>第三种情况，<strong>传入的第一个参数会成为执行方法的对象</strong>，例如<code>String::compareToIgnoreCase</code>，等价于<code>(x,y)-&gt;x.compareToIgnoreCase(y)</code>。<br>如果有多个同名的重载方法，编译器会试图从上下文中找到最匹配的方法，主要是通过方法参数确定。<br>和lambda表达式一样，方法引用也不会独立存在，它们经常被用于转换成函数式接口的实例。<br><strong>你可以在方法引用中使用this和super变量</strong>。<code>this::equals</code>等价于<code>x-&gt;this.equals(x)</code>。使用super可以引用父类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentGreeter</span> <span class="keyword">extends</span> <span class="title class_">Greeter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">super</span>::greet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在一个内部类中，你可以捕获闭合类型的<code>this</code>或<code>super</code>的引用,格式是<code>EnclosingClass.this::method</code>或<code>EnclosingClass.super::method</code>。看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentGreeter</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CGreeter</span> <span class="keyword">extends</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(ConcurrentGreeter.<span class="built_in">this</span>::greet).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Out Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ConcurrentGreeter</span> <span class="variable">concurrentGreeter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentGreeter</span>();</span><br><span class="line">ConcurrentGreeter.<span class="type">CGreeter</span> <span class="variable">cGreeter</span> <span class="operator">=</span> concurrentGreeter.<span class="keyword">new</span> <span class="title class_">CGreeter</span>();</span><br><span class="line">cGreeter.greet();</span><br></pre></td></tr></table></figure><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><p>构造器引用和方法应用是一样的，只是方法名<strong>固定是new</strong>。如果有多个构造器，那么选哪个呢？和方法引用遇到的问题的答案一样，这取决于上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; labels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">labels.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">labels.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">List&lt;Button&gt; buttons = labels.stream().map(Button::<span class="keyword">new</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>存在着多个Button构造器，但是编译器会选择有一String参数的构造器，因为它从上下文推测出调用构造器使用一个String。<br>你可以使用数组类型来建立构造器引用。比如，<code>int[]::new</code>是带一个参数的构造器引用,这个参数就是数组长度。它等价于<code>x-&gt;new int[x]</code>。<br>使用数组构造器引用可以很好的克服一个Java的限制。我们知道Java有类型擦除机制，所以在设计库的时候，<code>new T[]</code>这样是错误的，类型擦除会把它变成<code>new Object[]</code>。所以，<code>Stream</code>的一个方法<code>toArray</code>，它返回的类型是<code>Object</code>数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] btns = buttons.stream().toArray();</span><br></pre></td></tr></table></figure><p>但这样并不尽如人意，用户肯定是想要一个<code>Button</code>数组。通过数组构造器引用，Stream库解决了这个问题。你可以把<code>Button[]::new</code>传入<code>toArray</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button[] btns2= buttons.stream().toArray(Button[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>我们常常想要lambda表达式可以访问闭合方法或类中的变量。看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repeatMessage</span><span class="params">(String msg,<span class="type">int</span> count)</span>&#123;</span><br><span class="line">    Runnable runnable=() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下变量<code>msg</code>和<code>count</code>，它们都不是定义在lambda表达式中，而是方法<code>repeatMessage</code>的参数。<br>如果你仔细想想，这个lambda可能会运行很长时间，方法<code>repeatMessage</code>的调用已经返回，方法的参数也没了，那么<code>msg</code>和 <code>count</code>是怎么一直存在的呢？要理解发生了什么，需要先改变我们对lambda表达式的理解。一个lambda表达式有三个元素：</p><ul><li>一个代码块</li><li>参数</li><li><strong>自由变量的值。自由变量是指那些既不是lambda表达式的参数也不是在lambda代码块中的定义的变量</strong></li></ul><p>上面代码中的<code>msg</code>和<code>count</code>就是自由变量。可以说，这两个值已经被lambda<strong>捕获</strong>了。这是一个技术上的细节，如果你将一个lambda转换成一个只含有一个方法的对象，那么自由变量的值就会被复制到该对象的实例变量中。<br><strong>我们称含有自由变量的代码块为闭包</strong>。实际上，<strong>内部类一直都是闭包</strong>。Java8为闭包赋予了更吸引人的语法。<br>为了确保被捕获的值是良好定义的，需要遵守一个重要的约束：在lambda表达式中，被引用的变量的值不可以被更改。所以，下面的代码是不合法的：![java8-1-1.png](&#x2F;images&#x2F;20170730&#x2F;java8-1-1.png)<br>做出这种约束的原因是，<strong>更改lambda表达式中的变量不是线程安全的</strong>。<br>内部类也会捕获闭合作用域中的值。Java8之前，内部类只允许访问final的局部变量，为了适应lambda表达式，这条规则在Java8被放宽，<strong>一个内部类可以访问任何有效的final局部变量，即任何不会发生变化的值，并不一定要以final修饰</strong>。<br>但不可变的约束只作用在局部变量上，<strong>如果是一个实例变量或某个闭合类的静态变量，那么不会有任何的错误提示</strong>。同样的，改变一个共享对象也是完全合法的，即使这样不是很恰当：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) nums.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nums</code>是有效final的，因为它在初始化后没有被赋予新的值。但是，它内部的元素是可以修改的，所以仍然不是线程安全的。后面会介绍一些线程安全的集合。<br>既然lambda中引用的外部变量是不能更改的，那么怎么实现一个计数器呢？这个问题在使用内部类的时候就已经存在，方法是使用一个的长度为1的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter[]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">Runnable runnable=() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i+</span><br><span class="line">        counter[<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>lambda表达式中不允许声明一个与局部变量同名的参数或者局部变量：![java8-1-2.png](&#x2F;images&#x2F;20170730&#x2F;java8-1-2.png)<br><strong>当你在lambda表达式中使用this关键字时，你使用的是创建该lambda的方法的this参数</strong>。</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>很多语言都将函数表达式应用到了集合库中。Java8同样如此。但是，Java的集合库是很早就有的，如果要给<code>Collection</code>接口添加新的方法，如<code>forEach</code>,那么所有实现了<code>Collection</code>接口的类都必须实现这个方法，这令人无法接受也没有必要。Java的设计者通过允许接口带有具体实现的方法来一劳永逸的解决这个问题，这些方法就叫做默认方法。下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="string">&quot;JJZI&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认方法终结了以前的一种经典默认：模板方法模式。</strong> 即提供一个接口，以及一个实现接口大多数或者全部方法的抽象类，然后具体实现的类继承这个抽象类，只需实现少量方法就可以。现在，你不需要额外的抽象类了，只需要在接口中实现那些方法。<br>如果一个接口定义了一个默认方法，而另一个父类或接口中定义了一个同名的方法，该如何选择。规则是这样的：</p><ul><li><strong>如果一个父类提供了具体的实现方法，那么接口中具有相同名称和参数的默认方法会被忽略</strong>。</li><li>接口冲突。<strong>如果一个父接口提供了一个默认方法，而另一个父接口提供了一个具有相同名称和参数类型的方法(不论是不是默认方法),那么你必须通过覆盖该方法类解决冲突</strong>。</li></ul><p>我们来详细解释一下第二条规则。我们再定义一个接口，它也有<code>getName</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Named</span>&#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;<span class="keyword">return</span> getClass().getName()+<span class="string">&quot;_&quot;</span>+hashCode();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编写一个同时实现这<code>Person</code>和<code>Named</code>两个接口的类，编译器会报告一个错误，并交由开发人员来解决这种冲突，而不会自动选择一个。对于这种情况，只需要在这个类中提供一个<code>getName</code>方法，在改方法中再选择调用一个接口中的方法就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>,Named&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.<span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>Named</code>接口没有提供<code>getName</code>方法的一个默认实现，那么<code>Student</code>会继承<code>Person</code>接口中的默认方法吗？答案是，为了保持一致性，还是选择了和之前一样的处理方法。<strong>两个或多个接口中，只要有一个接口中有默认方法，其他类中不管是有默认方法还是抽象方法，都需要开发人员手动解决冲突</strong>。<br>如果<code>Person</code>是一个类，那么<code>Student</code>只会继承<code>Person</code>的<code>getName</code>方法，不管<code>Named</code>接口中的<code>getNamed</code>方法是不是默认方法。这就是类优先原则。这个原则可以保证与Java7兼容。如果你在接口中添加了一个默认方法，那么他对Java8以前编写的代码不会有任何影响。所以，<strong>你不能为Object的方法重新定义一个默认方法，因为类优先原则会让这样的方法永远不可能优先与Object中的方法</strong>。</p><h2 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h2><p><strong>Java8中，接口是可以添加静态方法的</strong>。技术上，这是完全没问题的，但这看起来违反了接口作为一个抽象定义的原则。<br>至今，我们经常在相互一起使用的类中使用静态方法，如标准库中的Collection&#x2F;Collections或者Path&#x2F;Paths这样成对的接口和类。以<code>Paths</code>为例子，它有一些工程方法，用来产生<code>Path</code>。在Java8中，你可以把这些方法移到<code>Path</code>接口中，这样<code>Paths</code>就没必要存在了。<br>再看<code>Collections</code>，你会看到下面的这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span><br></pre></td></tr></table></figure><p>这个方法可以作为<code>List</code>接口的默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> defualt <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>然后只需要在任意的list对象上调用<code>list.shuffle()</code>就可以了。<br>但是，这样无法适用于静态的工厂方法，因为没有实例来调用这个方法。因此，Java8引入了静态接口方法。例如,可以把<code>Collections</code>中的<code>nCopies</code>方法移到<code>List</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">nCopies</span><span class="params">(<span class="type">int</span> n,T o)</span></span><br></pre></td></tr></table></figure><p>这样就可以调用<code>List.nCopies(10,&quot;jjzi&quot;)</code>而不是<code>Collections.nCopies(10,&quot;jjzi&quot;)</code>，这样能够清楚的表示返回的结果是一个<code>List</code>。<br>虽然为了兼容性，不太可能这么大幅度的重构，但是当你实现自己的库的时候，可以考虑使用这种方式，不必在添加一个额外的辅助类存放静态方法。<br>Java8中，很多接口已经添加了静态方法。例如，<code>Comparator</code>接口提供了一个很实用的比较方法，它接受一个键提取函数，并返回一个用来比较提取出的键的比较器。比如，要根据名称对<code>Person</code>对象进行比较，可以使用函数<code>Comparator.comparing(Person::getName)</code>。<br>在之前，我们曾经使用lambda表达式<code>(first,second)-&gt;Integer.compare(first.length(),second.length())</code>，其实可以使用<code>Comparator</code>的静态比较方法，代码会更简洁。例如<code>Comparator.comparingInt(String::length)</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近开始看&amp;lt;&amp;lt;写给大忙人看到Java SE 8&amp;gt;&amp;gt;,由于和我看过的《快学Scala》是一个系列的，所以姑且叫它《快学Java8》。这一篇是第一章的看书笔记，以后每个章节也都会有一篇笔记。&lt;/p&gt;
&lt;h2 id=&quot;为什么要引入Lambda表达式&quot;&gt;&lt;a href=&quot;#为什么要引入Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;为什么要引入Lambda表达式&quot;&gt;&lt;/a&gt;为什么要引入Lambda表达式&lt;/h2&gt;&lt;p&gt;Java引入的最重要的特性是lambda表达式。lambda表达式实际上是一段可以传递的代码。在Java8之前，由于Java的设计问题，要传递代码必须构造一个类的对象，它的某个方法包含了需要的代码。看个例子：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java Java8" scheme="https://zjjfly.github.io/tags/Java-Java8/"/>
    
  </entry>
  
  <entry>
    <title>rsync使用心得</title>
    <link href="https://zjjfly.github.io/2017/07/28/2017-7-28-rsync%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://zjjfly.github.io/2017/07/28/2017-7-28-rsync%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</id>
    <published>2017-07-28T01:32:28.000Z</published>
    <updated>2023-05-03T02:26:38.685Z</updated>
    
    <content type="html"><![CDATA[<p>本人有一段时间就职于某市的公积金项目，项目每次上线新的功能，都要复制代码到多个服务器上，手动复制显得很繁琐，可靠性也无法保障。所以曾探索使用rsync进行自动复制，但由于种种原因最终未能投入生产环境，在此把一些经验和大家分享。<br>下面的内容需要在已安装rsync的机器上运行，安装方法可以自行搜索。</p><span id="more"></span><h2 id="1-启动"><a href="#1-启动" class="headerlink" title="1.启动"></a>1.启动</h2><p>先查看一下rsync是否已经启动，运行命令ps -ef|grep rsync，下图就是已经启动了的。<br>![rsync.png](&#x2F;images&#x2F;20170728&#x2F;rsync.png)<br>如没有启动，运行命令&#x2F;usr&#x2F;bin&#x2F;rsync –daemon，再次运行上面那个命令看是否启动成功。</p><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><hr><h3 id="2-1服务器端配置"><a href="#2-1服务器端配置" class="headerlink" title="2.1服务器端配置"></a>2.1服务器端配置</h3><p>首先进入&#x2F;etc目录，创建一个文件rsyncd.conf,内容可以像下面这样(每一行的第一个数字是行号)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1 pid file=/var/rsynclog/rsyncd.pid</span><br><span class="line">2 log file=/var/rsynclog/rsyncd.log</span><br><span class="line">3 lock file=/var/rsynclog/rsync.lock</span><br><span class="line">4 motd file=/etc/rsyncd.motd</span><br><span class="line">5 port=808</span><br><span class="line">6 address=192.168.1.1</span><br><span class="line">7 hosts allow=192.168.1.2</span><br><span class="line">8 hosts deny=0.0.0.0/0</span><br><span class="line">9 uid=weblogic</span><br><span class="line">10 gid=bea</span><br><span class="line">11 max connections=10</span><br><span class="line">12 [deploy]</span><br><span class="line">13 path=/tmp/test/testsync</span><br><span class="line">14 comment=test for use</span><br><span class="line">15 exclude=/WEB-INF/apps/loan/portal_config.xml /WEB- INF/apps/loan/view_config.xml</span><br><span class="line">16 ignore errors</span><br><span class="line">17 read only=yes</span><br><span class="line">18 hosts allow=192.168.1.2</span><br><span class="line">19 hosts deny=0.0.0.0/0</span><br><span class="line">20 list=yes</span><br><span class="line">21 auth users=weblogic</span><br><span class="line">22 secrets file=/etc/rsyncd.secrets</span><br></pre></td></tr></table></figure><p>接下来我对这些配置的意义做一些说明。<br>第1行，线程文件路径，用来存放rsync的进程号。<br>第2行，日志文件的路径，同步的日志主要就是在此文件中。<br>第3行，锁文件的路径。<br>第4行，欢迎文件，可自定义。<br>第5行，rsync daemon的传输端口，默认就是083。<br>第6行，rsync daemon监听的IP，默认是当前地址。<br>第7行，允许的客户端ip。<br>第8行，屏蔽的客户端ip。<br>第9行，运行该服务的用户，可以配置在模块中。<br>第10行，运行该服务的用户所属的组，可以配置在模块中。<br>第11行，最大连接数。<br>第12行，模块名，自己取。<br>第13行，该模块的路径，比如需要同步的工程所在的目录。<br>第14行，运行同步时的注释，自定义。<br>第15行，同步时排除的文件，这些文件就不会同步了，一般是配置文件。<br>第16行，可以忽略一些无关的IO错误。<br>第17行，客户端对于服务端的文件是否只读，如果是false的客户端可以上传文件。<br>第18行，同第7行。<br>第19行，同第8行。<br>第20行，是否把rsync服务器上提供同步数据的目录显示。<br>第21行，同步验证时用的账号。如果没有这项就是匿名同步，客户端同步时不需要用户名也能同步，所以不推荐这样做。<br>第22行，认证文件的路径。<br>接下来就是配置认证文件。创建一个文件rsyncd.secrets,内容可以像下面这样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:rootby</span><br><span class="line">weblogic:weblogic</span><br></pre></td></tr></table></figure><p>格式是“用户名:密码”。注意,这个文件的权限要设成600命令是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +600 /etc/rsync.secrets</span><br></pre></td></tr></table></figure><p>首先，创建一个密码文件rsync.pwd,内容可以像下面这样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weblogic</span><br></pre></td></tr></table></figure><p>这个文件只包含密码部分，是服务器配置文件中配置的uid的密码。这个文件的权限也是要设置成600。<br>至此，配置的工作已经结束了。</p><h2 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3.常用命令"></a>3.常用命令</h2><hr><h3 id="3-1-本地同步"><a href="#3-1-本地同步" class="headerlink" title="3.1 本地同步"></a>3.1 本地同步</h3><p>rsync可以在本地同步文件，命令可以是下面这样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz testsync /tmp/test</span><br></pre></td></tr></table></figure><p>把当前目录的testsync文件夹同步到&#x2F;tmp&#x2F;test目录下，如果&#x2F;tmp&#x2F;test下面之前没有testsync文件夹，那就相当于把testsync复制到&#x2F;tmp&#x2F;test下，如果已经有了，则会把当前目录下的testsync文件夹相对于&#x2F;tmp&#x2F;test&#x2F;testsync不一样的部分复制过去。<br>如果输入如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --delete testsync /tmp/test/</span><br></pre></td></tr></table></figure><p>和上面那条功能基本相似，但会把&#x2F;tmp&#x2F;test&#x2F;testsync中相对当前目录下的testsync文件夹的内容多余的部分删除掉（例如，&#x2F;tmp&#x2F;test&#x2F;testsync下有1.txt，2.txt，3.txt这几个文件，前目录下的testsync文件夹有1.txt，2.txt，其中两个文件夹中的1.txt和2.txt内容完全一致，则用这个命令同步时会把3.txt删除。</p><p>上面两个命令带的-avz和—delete可以用在下面所有提到的命令。</p><h3 id="3-2-pull"><a href="#3-2-pull" class="headerlink" title="3.2 pull"></a>3.2 pull</h3><p>pull就是客户端主动请求和服务器端同步，命令如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -azv--password-file=/tmp/rsync.pwd weblogic@192.168.1.1::deploy /tmp/deploy/</span><br></pre></td></tr></table></figure><p>其中，–password-file参数是指明密码文件的路径，weblogic是同步时用的用户，@后面的ip是服务器地址，：：后的deploy是服务器配置文件中的一个模块的名称，最后的路径就是客户端需要同步的目录</p><h3 id="3-3-push"><a href="#3-3-push" class="headerlink" title="3.3.push"></a>3.3.push</h3><p>push是客户端主动把文件同步到服务器端，命令如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -azv--password-file=/tmp/rsync.pwd /tmp/test/deploy/ weblogic@192.168.1.1::deploy</span><br></pre></td></tr></table></figure><p>参数基本和pull的一样，只是把客户端要同步的文件路径放到了前面。<br>对于那些需要发布多份相同代码到多个服务器上的情况，本人建议用这种方式去同步，只需要先上传到一台机器上，然后把代码push到其他的机器上即可。</p><h2 id="4．参考资料"><a href="#4．参考资料" class="headerlink" title="4．参考资料"></a>4．参考资料</h2><hr><p><a href="http://www.iteye.com/topic/604436">http://www.iteye.com/topic/604436</a><br><a href="http://www.cnblogs.com/chijianqiang/archive/2011/05/09/2041537.html">http://www.cnblogs.com/chijianqiang/archive/2011/05/09/2041537.html</a><br><a href="http://blog.chinaunix.net/uid-24960107-id-279170.html">http://blog.chinaunix.net/uid-24960107-id-279170.html</a><br><a href="http://wanwentao.blog.51cto.com/2406488/579008">http://wanwentao.blog.51cto.com/2406488/579008</a><br><a href="http://blog.sina.com.cn/s/blog_5eda2dda01015fcs.html">http://blog.sina.com.cn/s/blog_5eda2dda01015fcs.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本人有一段时间就职于某市的公积金项目，项目每次上线新的功能，都要复制代码到多个服务器上，手动复制显得很繁琐，可靠性也无法保障。所以曾探索使用rsync进行自动复制，但由于种种原因最终未能投入生产环境，在此把一些经验和大家分享。&lt;br&gt;下面的内容需要在已安装rsync的机器上运行，安装方法可以自行搜索。&lt;/p&gt;</summary>
    
    
    
    
    <category term="rsync" scheme="https://zjjfly.github.io/tags/rsync/"/>
    
  </entry>
  
</feed>
